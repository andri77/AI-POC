"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const api = __importStar(require("../rest/api"));
const config_1 = __importDefault(require("../services/config"));
const core_1 = require("@oclif/core");
const authCommand_1 = require("./authCommand");
const project_parser_1 = require("../services/project-parser");
const checkly_config_loader_1 = require("../services/checkly-config-loader");
const constructs_1 = require("../constructs");
const util_1 = require("../services/util");
const common_messages_1 = __importDefault(require("../messages/common-messages"));
class Validate extends authCommand_1.AuthCommand {
    static coreCommand = true;
    static hidden = true; // Expose when validation is more thorough.
    static description = 'Validate your project.';
    static flags = {
        'config': core_1.Flags.string({
            char: 'c',
            description: common_messages_1.default.configFile,
        }),
        'verify-runtime-dependencies': core_1.Flags.boolean({
            description: '[default: true] Return an error if checks import dependencies that are not supported by the selected runtime.',
            default: true,
            allowNo: true,
            env: 'CHECKLY_VERIFY_RUNTIME_DEPENDENCIES',
        }),
    };
    async run() {
        this.style.actionStart('Parsing your project');
        const { flags } = await this.parse(Validate);
        const { config: configFilename, 'verify-runtime-dependencies': verifyRuntimeDependencies, } = flags;
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        const { config: checklyConfig, constructs: checklyConfigConstructs, } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames);
        const { data: account } = await api.accounts.get(config_1.default.getAccountId());
        const { data: avilableRuntimes } = await api.runtimes.getAll();
        const project = await (0, project_parser_1.parseProject)({
            directory: configDirectory,
            projectLogicalId: checklyConfig.logicalId,
            projectName: checklyConfig.projectName,
            repoUrl: checklyConfig.repoUrl,
            checkMatch: checklyConfig.checks?.checkMatch,
            browserCheckMatch: checklyConfig.checks?.browserChecks?.testMatch,
            multiStepCheckMatch: checklyConfig.checks?.multiStepChecks?.testMatch,
            ignoreDirectoriesMatch: checklyConfig.checks?.ignoreDirectoriesMatch,
            checkDefaults: checklyConfig.checks,
            browserCheckDefaults: checklyConfig.checks?.browserChecks,
            availableRuntimes: avilableRuntimes.reduce((acc, runtime) => {
                acc[runtime.name] = runtime;
                return acc;
            }, {}),
            defaultRuntimeId: account.runtimeId,
            verifyRuntimeDependencies,
            checklyConfigConstructs,
            playwrightConfigPath: checklyConfig.checks?.playwrightConfigPath,
            include: checklyConfig.checks?.include,
            playwrightChecks: checklyConfig.checks?.playwrightChecks,
        });
        this.style.actionSuccess();
        this.style.actionStart('Validating project resources');
        const diagnostics = new constructs_1.Diagnostics();
        await project.validate(diagnostics);
        for (const diag of diagnostics.observations) {
            if (diag.isFatal()) {
                this.style.longError(diag.title, diag.message);
            }
            else if (!diag.isBenign()) {
                this.style.longWarning(diag.title, diag.message);
            }
            else {
                this.style.longInfo(diag.title, diag.message);
            }
        }
        if (diagnostics.isFatal()) {
            this.style.actionFailure();
            this.style.shortError(`Your project is not valid.`);
            this.exit(1);
        }
        this.style.actionSuccess();
        this.style.shortSuccess(`Your project is valid.`);
    }
}
exports.default = Validate;
//# sourceMappingURL=validate.js.map