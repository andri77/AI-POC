"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const baseCommand_1 = require("./baseCommand");
const promises_1 = require("fs/promises");
const path_1 = __importStar(require("path"));
const fs_1 = require("fs");
const prompts_1 = __importDefault(require("prompts"));
const BASE_RULES_FILE_PATH = (0, path_1.join)(__dirname, '../rules/checkly.rules.md');
// AI IDE configurations mapping
const AI_IDE_CONFIGS = {
    'Windsurf': {
        rulesFolder: '.windsurf/rules',
        rulesFileName: 'checkly.md',
    },
    'GitHub Copilot': {
        rulesFolder: '.github/instructions',
        rulesFileName: 'checkly.instructions.md',
    },
    'Cursor': {
        rulesFolder: '.cursor/rules',
        rulesFileName: 'checkly.mdc',
    },
    'Plain Markdown (checkly.md)': {
        rulesFolder: '.',
        rulesFileName: 'checkly.md',
    },
};
class Rules extends baseCommand_1.BaseCommand {
    static hidden = false;
    static description = 'Generate a rules file to use with AI IDEs and Copilots.';
    async run() {
        // Read the base rules file
        const rulesContent = await this.readBaseRulesFile();
        if (!rulesContent) {
            this.error(`Failed to read rules file at ${BASE_RULES_FILE_PATH}`);
        }
        // In non-interactive mode, print rules to stdout and exit
        const isNonInteractive = !process.stdin.isTTY
            || !process.stdout.isTTY
            || process.env.CI
            || process.env.CHECKLY_NON_INTERACTIVE;
        if (isNonInteractive) {
            this.log(rulesContent);
            return;
        }
        try {
            // Create options for multiselect - offer all configs from AI_IDE_CONFIGS
            const choices = Object.entries(AI_IDE_CONFIGS).map(([ideName, ideConfig]) => {
                return {
                    title: `${ideName} (${path_1.default.join(ideConfig.rulesFolder, ideConfig.rulesFileName)})`,
                    value: ideConfig,
                    selected: false,
                };
            });
            const isNonInteractive = !process.stdin.isTTY
                || !process.stdout.isTTY
                || process.env.CI
                || process.env.CHECKLY_NON_INTERACTIVE;
            // Interactive mode - show multiselect
            const { configs: selectedConfig } = await (0, prompts_1.default)({
                type: 'select',
                name: 'configs',
                message: 'Select the AI IDE configurations to generate rules for:',
                choices,
                initial: 0,
            });
            if (!selectedConfig) {
                this.log('Operation cancelled.');
                return;
            }
            this.log(`Generating rules`);
            // Create rules directory if it doesn't exist
            const rulesDir = (0, path_1.join)(process.cwd(), selectedConfig.rulesFolder);
            try {
                await (0, promises_1.mkdir)(rulesDir, { recursive: true });
            }
            catch {
                // Directory might already exist, ignore error
            }
            // Determine the target file path
            const rulesFilePath = (0, path_1.join)(rulesDir, selectedConfig.rulesFileName);
            // Check if file already exists and ask for confirmation (only in interactive mode)
            let shouldOverwrite = true;
            if (!isNonInteractive) {
                shouldOverwrite = await this.confirmOverwrite(rulesFilePath);
            }
            if (!shouldOverwrite) {
                this.log(`Skipped ${rulesFilePath}`);
                return;
            }
            // Save the rules file
            await (0, promises_1.writeFile)(rulesFilePath, rulesContent, 'utf8');
            this.log(`âœ… Successfully saved Checkly rules file to: ${rulesFilePath}`);
        }
        catch (error) {
            this.error(`Failed to generate rules file: ${error}`);
        }
    }
    async readBaseRulesFile() {
        try {
            return await (0, promises_1.readFile)(BASE_RULES_FILE_PATH, 'utf8');
        }
        catch (error) {
            throw new Error(`Failed to read base rules file at ${BASE_RULES_FILE_PATH}: ${error}`);
        }
    }
    async confirmOverwrite(targetPath) {
        try {
            await (0, promises_1.access)(targetPath, fs_1.constants.F_OK);
            // File exists, ask for confirmation
            const { overwrite } = await (0, prompts_1.default)({
                type: 'confirm',
                name: 'overwrite',
                message: `Rules file already exists at ${targetPath}. Do you want to overwrite it?`,
                initial: false,
            });
            return overwrite ?? false;
        }
        catch {
            // File doesn't exist, no need to confirm
            return true;
        }
    }
}
exports.default = Rules;
//# sourceMappingURL=rules.js.map