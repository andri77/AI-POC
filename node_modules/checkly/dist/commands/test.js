"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const indent_string_1 = __importDefault(require("indent-string"));
const api = __importStar(require("../rest/api"));
const config_1 = __importDefault(require("../services/config"));
const project_parser_1 = require("../services/project-parser");
const abstract_check_runner_1 = require("../services/abstract-check-runner");
const test_runner_1 = __importDefault(require("../services/test-runner"));
const checkly_config_loader_1 = require("../services/checkly-config-loader");
const test_filters_1 = require("../services/test-filters");
const authCommand_1 = require("./authCommand");
const constructs_1 = require("../constructs");
const util_1 = require("../services/util");
const reporter_1 = require("../reporters/reporter");
const common_messages_1 = __importDefault(require("../messages/common-messages"));
const util_2 = require("../reporters/util");
const snapshot_service_1 = require("../services/snapshot-service");
const construct_1 = require("../constructs/construct");
const browser_check_bundle_1 = require("../constructs/browser-check-bundle");
const test_helper_1 = require("../helpers/test-helper");
const MAX_RETRIES = 3;
class Test extends authCommand_1.AuthCommand {
    static coreCommand = true;
    static hidden = false;
    static description = 'Test your checks on Checkly.';
    static flags = {
        'location': core_1.Flags.string({
            char: 'l',
            description: 'The location to run the checks at.',
        }),
        'private-location': core_1.Flags.string({
            description: 'The private location to run checks at.',
            exclusive: ['location'],
        }),
        'grep': core_1.Flags.string({
            char: 'g',
            description: 'Only run checks where the check name matches a regular expression.',
            default: '.*',
        }),
        'tags': core_1.Flags.string({
            char: 't',
            description: 'Filter the checks to be run using a comma separated list of tags.'
                + ' Checks will only be run if they contain all of the specified tags.'
                + ' Multiple --tags flags can be passed, in which case checks will be run if they match any of the --tags filters.'
                + ' F.ex. `--tags production,webapp --tags production,backend` will run checks with tags (production AND webapp) OR (production AND backend).',
            multiple: true,
            required: false,
        }),
        'env': core_1.Flags.string({
            char: 'e',
            description: 'Env vars to be passed to the test run.',
            exclusive: ['env-file'],
            multiple: true,
            default: [],
        }),
        'env-file': core_1.Flags.string({
            description: 'dotenv file path to be passed. For example --env-file="./.env"',
            exclusive: ['env'],
        }),
        'list': core_1.Flags.boolean({
            default: false,
            description: 'list all checks but don\'t run them.',
        }),
        'timeout': core_1.Flags.integer({
            default: abstract_check_runner_1.DEFAULT_CHECK_RUN_TIMEOUT_SECONDS,
            description: 'A timeout (in seconds) to wait for checks to complete.',
        }),
        'verbose': core_1.Flags.boolean({
            char: 'v',
            description: 'Always show the full logs of the checks.',
            allowNo: true,
        }),
        'reporter': core_1.Flags.string({
            char: 'r',
            description: 'A list of custom reporters for the test output.',
            options: ['list', 'dot', 'ci', 'github', 'json'],
        }),
        'config': core_1.Flags.string({
            char: 'c',
            description: common_messages_1.default.configFile,
        }),
        'record': core_1.Flags.boolean({
            description: 'Record test results in Checkly as a test session with full logs, traces and videos.',
            default: false,
        }),
        'test-session-name': core_1.Flags.string({
            char: 'n',
            description: 'A name to use when storing results in Checkly with --record.',
        }),
        'update-snapshots': core_1.Flags.boolean({
            char: 'u',
            description: 'Update any snapshots using the actual result of this test run.',
            default: false,
        }),
        'retries': core_1.Flags.integer({
            description: `[default: 0, max: ${MAX_RETRIES}] How many times to retry a failing test run.`,
        }),
        'verify-runtime-dependencies': core_1.Flags.boolean({
            description: '[default: true] Return an error if checks import dependencies that are not supported by the selected runtime.',
            default: true,
            allowNo: true,
            env: 'CHECKLY_VERIFY_RUNTIME_DEPENDENCIES',
        }),
    };
    static args = {
        fileArgs: core_1.Args.string({
            name: 'files',
            required: false,
            description: 'Only run checks where the file name matches a regular expression',
            default: '.*',
        }),
    };
    static strict = false;
    async run() {
        this.style.actionStart('Parsing your project');
        const { flags, argv } = await this.parse(Test);
        const { location: runLocation, 'private-location': privateRunLocation, grep, tags: targetTags, env, 'env-file': envFile, list, timeout, verbose: verboseFlag, reporter: reporterFlag, config: configFilename, record: shouldRecord, 'test-session-name': testSessionName, 'update-snapshots': updateSnapshots, retries, 'verify-runtime-dependencies': verifyRuntimeDependencies, } = flags;
        const filePatterns = argv;
        const testEnvVars = await (0, util_1.getEnvs)(envFile, env);
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        const { config: checklyConfig, constructs: checklyConfigConstructs, } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames);
        const location = await (0, test_helper_1.prepareRunLocation)(checklyConfig.cli, {
            runLocation: runLocation,
            privateRunLocation,
        }, api, config_1.default.getAccountId());
        const verbose = this.prepareVerboseFlag(verboseFlag, checklyConfig.cli?.verbose);
        const reporterTypes = (0, test_helper_1.prepareReportersTypes)(reporterFlag, checklyConfig.cli?.reporters);
        const { data: account } = await api.accounts.get(config_1.default.getAccountId());
        const { data: availableRuntimes } = await api.runtimes.getAll();
        const project = await (0, project_parser_1.parseProject)({
            directory: configDirectory,
            projectLogicalId: checklyConfig.logicalId,
            projectName: testSessionName ?? checklyConfig.projectName,
            repoUrl: checklyConfig.repoUrl,
            includeTestOnlyChecks: true,
            checkMatch: checklyConfig.checks?.checkMatch,
            browserCheckMatch: checklyConfig.checks?.browserChecks?.testMatch,
            multiStepCheckMatch: checklyConfig.checks?.multiStepChecks?.testMatch,
            ignoreDirectoriesMatch: checklyConfig.checks?.ignoreDirectoriesMatch,
            checkDefaults: checklyConfig.checks,
            browserCheckDefaults: checklyConfig.checks?.browserChecks,
            availableRuntimes: availableRuntimes.reduce((acc, runtime) => {
                acc[runtime.name] = runtime;
                return acc;
            }, {}),
            defaultRuntimeId: account.runtimeId,
            verifyRuntimeDependencies,
            checklyConfigConstructs,
            playwrightConfigPath: checklyConfig.checks?.playwrightConfigPath,
            include: checklyConfig.checks?.include,
            playwrightChecks: checklyConfig.checks?.playwrightChecks,
            checkFilter: check => {
                if (check instanceof constructs_1.HeartbeatMonitor) {
                    return false;
                }
                let entrypointMatch = false;
                if (check instanceof constructs_1.BrowserCheck || check instanceof constructs_1.MultiStepCheck) {
                    // For historical reasons the path used for filtering has always
                    // been relative to the project base path.
                    const relativeEntrypoint = (0, construct_1.isEntrypoint)(check.code)
                        ? constructs_1.Session.relativePosixPath(check.code.entrypoint)
                        : undefined;
                    if (relativeEntrypoint) {
                        if ((0, test_filters_1.filterByFileNamePattern)(filePatterns, relativeEntrypoint)) {
                            entrypointMatch = true;
                        }
                    }
                }
                if (!entrypointMatch && !(0, test_filters_1.filterByFileNamePattern)(filePatterns, check.getSourceFile())) {
                    return false;
                }
                if (!(0, test_filters_1.filterByCheckNamePattern)(grep, check.name)) {
                    return false;
                }
                const tags = [...check.tags ?? []];
                const checkGroup = this.getCheckGroup(project, check);
                if (checkGroup) {
                    const checkGroupTags = checkGroup.tags ?? [];
                    tags.push(...checkGroupTags);
                }
                if (!(0, test_filters_1.filterByTags)(targetTags?.map((tags) => tags.split(',')) ?? [], tags)) {
                    return false;
                }
                // FIXME: This should not be done here (not related to filtering).
                if (Object.keys(testEnvVars).length) {
                    if (check instanceof constructs_1.RuntimeCheck) {
                        check.environmentVariables = check.environmentVariables
                            ?.filter((envVar) => !testEnvVars[envVar.key]) || [];
                        for (const [key, value] of Object.entries(testEnvVars)) {
                            check.environmentVariables.push({
                                key,
                                value,
                                locked: true,
                            });
                        }
                    }
                }
                return true;
            },
        });
        this.style.actionSuccess();
        this.style.actionStart('Validating project resources');
        const diagnostics = new constructs_1.Diagnostics();
        await project.validate(diagnostics);
        for (const diag of diagnostics.observations) {
            if (diag.isFatal()) {
                this.style.longError(diag.title, diag.message);
            }
            else if (!diag.isBenign()) {
                this.style.longWarning(diag.title, diag.message);
            }
            else {
                this.style.longInfo(diag.title, diag.message);
            }
        }
        if (diagnostics.isFatal()) {
            this.style.actionFailure();
            this.style.shortError(`Unable to continue due to unresolved validation errors.`);
            this.exit(1);
        }
        this.style.actionSuccess();
        this.style.actionStart('Bundling project resources');
        const projectBundle = await (async () => {
            try {
                const bundle = await project.bundle();
                this.style.actionSuccess();
                return bundle;
            }
            catch (err) {
                this.style.actionFailure();
                throw err;
            }
        })();
        const checkBundles = Object.values(projectBundle.data.check);
        for (const { bundle: check } of checkBundles) {
            if (!(check instanceof browser_check_bundle_1.BrowserCheckBundle)) {
                continue;
            }
            check.snapshots = await (0, snapshot_service_1.uploadSnapshots)(check.rawSnapshots);
        }
        if (this.fancy) {
            core_1.ux.action.stop();
        }
        if (!checkBundles.length) {
            this.log(`Unable to find checks to run${filePatterns[0] !== '.*' ? ' using [FILEARGS]=\'' + filePatterns + '\'' : ''}.`);
            return;
        }
        if (list) {
            this.listChecks(checkBundles.map(({ construct }) => construct));
            return;
        }
        const reporters = (0, reporter_1.createReporters)(reporterTypes, location, verbose);
        const repoInfo = (0, util_1.getGitInformation)(project.repoUrl);
        const ciInfo = (0, util_1.getCiInformation)();
        const testRetryStrategy = this.prepareTestRetryStrategy(retries, checklyConfig?.cli?.retries);
        const runner = new test_runner_1.default(config_1.default.getAccountId(), projectBundle, checkBundles, constructs_1.Session.sharedFiles, location, timeout, verbose, shouldRecord, repoInfo, ciInfo.environment, updateSnapshots, configDirectory, testRetryStrategy);
        runner.on(abstract_check_runner_1.Events.RUN_STARTED, (checks, testSessionId) => reporters.forEach(r => r.onBegin(checks, testSessionId)));
        runner.on(abstract_check_runner_1.Events.CHECK_INPROGRESS, (check, sequenceId) => {
            reporters.forEach(r => r.onCheckInProgress(check, sequenceId));
        });
        runner.on(abstract_check_runner_1.Events.MAX_SCHEDULING_DELAY_EXCEEDED, () => {
            reporters.forEach(r => r.onSchedulingDelayExceeded());
        });
        runner.on(abstract_check_runner_1.Events.CHECK_ATTEMPT_RESULT, (sequenceId, check, result, links) => {
            reporters.forEach(r => r.onCheckAttemptResult(sequenceId, {
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                ...result,
            }, links));
        });
        runner.on(abstract_check_runner_1.Events.CHECK_SUCCESSFUL, (sequenceId, check, result, testResultId, links) => {
            if (result.hasFailures) {
                process.exitCode = 1;
            }
            reporters.forEach(r => r.onCheckEnd(sequenceId, {
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                ...result,
            }, testResultId, links));
        });
        runner.on(abstract_check_runner_1.Events.CHECK_FAILED, (sequenceId, check, message) => {
            reporters.forEach(r => r.onCheckEnd(sequenceId, {
                ...check,
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                hasFailures: true,
                runError: message,
            }));
            process.exitCode = 1;
        });
        runner.on(abstract_check_runner_1.Events.RUN_FINISHED, () => reporters.forEach(r => r.onEnd()));
        runner.on(abstract_check_runner_1.Events.ERROR, err => {
            reporters.forEach(r => r.onError(err));
            process.exitCode = 1;
        });
        await runner.run();
    }
    prepareVerboseFlag(verboseFlag, cliVerboseFlag) {
        return verboseFlag ?? cliVerboseFlag ?? false;
    }
    prepareTestRetryStrategy(retries, configRetries) {
        const numRetries = retries ?? configRetries ?? 0;
        if (numRetries > MAX_RETRIES) {
            (0, util_2.printLn)(`Defaulting to the maximum of ${MAX_RETRIES} retries.`);
        }
        return numRetries
            ? constructs_1.RetryStrategyBuilder.fixedStrategy({
                maxRetries: Math.min(numRetries, MAX_RETRIES),
                baseBackoffSeconds: 0,
            })
            : null;
    }
    listChecks(checks) {
        // Sort and print the checks in a way that's consistent with AbstractListReporter
        const sortedCheckFiles = [...new Set(checks.map(check => check.getSourceFile()))].sort();
        const sortedChecks = checks.sort((a, b) => a.name.localeCompare(b.name));
        const checkFilesMap = new Map(sortedCheckFiles.map(file => [file, []]));
        sortedChecks.forEach(check => {
            checkFilesMap.get(check.getSourceFile()).push(check);
        });
        (0, util_2.printLn)('Listing all checks:', 2, 1);
        for (const [sourceFile, checks] of checkFilesMap) {
            (0, util_2.printLn)(sourceFile);
            for (const check of checks) {
                (0, util_2.printLn)((0, indent_string_1.default)((0, util_2.formatCheckTitle)(util_2.CheckStatus.RUNNING, check), 2));
            }
        }
    }
    getCheckGroup(project, check) {
        if (!check.groupId) {
            return;
        }
        const ref = check.groupId.ref.toString();
        return project.data['check-group'][ref];
    }
}
exports.default = Test;
//# sourceMappingURL=test.js.map