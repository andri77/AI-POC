"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const authCommand_1 = require("./authCommand");
const util_1 = require("../services/util");
const checkly_config_loader_1 = require("../services/checkly-config-loader");
const test_helper_1 = require("../helpers/test-helper");
const api = __importStar(require("../rest/api"));
const config_1 = __importDefault(require("../services/config"));
const project_parser_1 = require("../services/project-parser");
const constructs_1 = require("../constructs");
const core_1 = require("@oclif/core");
const reporter_1 = require("../reporters/reporter");
const test_runner_1 = __importDefault(require("../services/test-runner"));
const abstract_check_runner_1 = require("../services/abstract-check-runner");
const common_messages_1 = __importDefault(require("../messages/common-messages"));
const node_path_1 = __importDefault(require("node:path"));
const recast = __importStar(require("recast"));
const write_config_helpers_1 = require("../helpers/write-config-helpers");
const JSON5 = __importStar(require("json5"));
const package_manager_1 = require("../services/check-parser/package-files/package-manager");
const constants_1 = require("../helpers/constants");
const sourcegen_1 = require("../sourcegen");
class PwTestCommand extends authCommand_1.AuthCommand {
    static coreCommand = true;
    static hidden = false;
    static description = 'Test your Playwright Tests on Checkly.';
    static state = 'beta';
    static flags = {
        'location': core_1.Flags.string({
            char: 'l',
            description: 'The location to run the checks at.',
        }),
        'private-location': core_1.Flags.string({
            description: 'The private location to run checks at.',
            exclusive: ['location'],
        }),
        'env': core_1.Flags.string({
            char: 'e',
            description: 'Env vars to be passed to the test run.',
            exclusive: ['env-file'],
            multiple: true,
            default: [],
        }),
        'env-file': core_1.Flags.string({
            description: 'dotenv file path to be passed. For example --env-file="./.env"',
            exclusive: ['env'],
        }),
        'timeout': core_1.Flags.integer({
            default: abstract_check_runner_1.DEFAULT_CHECK_RUN_TIMEOUT_SECONDS,
            description: 'A timeout (in seconds) to wait for checks to complete.',
        }),
        'verbose': core_1.Flags.boolean({
            description: 'Always show the full logs of the checks.',
        }),
        'reporter': core_1.Flags.string({
            description: 'A list of custom reporters for the test output.',
            options: ['list', 'dot', 'ci', 'github', 'json'],
        }),
        'config': core_1.Flags.string({
            description: common_messages_1.default.configFile,
        }),
        'record': core_1.Flags.boolean({
            description: 'Record test results in Checkly as a test session with full logs, traces and videos.',
            default: true,
            allowNo: true,
        }),
        'test-session-name': core_1.Flags.string({
            description: 'A name to use when storing results in Checkly',
        }),
        'create-check': core_1.Flags.boolean({
            description: 'Create a Checkly check from the Playwright test.',
            default: false,
        }),
    };
    async run() {
        this.style.actionStart('Parsing your Playwright project');
        const { checklyFlags, playwrightFlags } = (0, test_helper_1.splitChecklyAndPlaywrightFlags)(this.argv);
        const { flags } = await this.parse(PwTestCommand, checklyFlags);
        const { location: runLocation, 'private-location': privateRunLocation, env = [], 'env-file': envFile, timeout, verbose: verboseFlag, reporter: reporterFlag, config: configFilename, record, 'test-session-name': testSessionName, 'create-check': createCheck, } = flags;
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        const { config: checklyConfig, constructs: checklyConfigConstructs, } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames, false);
        const playwrightConfigPath = this.getConfigPath(playwrightFlags) ?? checklyConfig.checks?.playwrightConfigPath;
        const dir = node_path_1.default.dirname(playwrightConfigPath || '.');
        const playwrightCheck = await PwTestCommand.createPlaywrightCheck(playwrightFlags, runLocation, privateRunLocation, dir);
        if (createCheck) {
            this.style.actionStart('Creating Checkly check from Playwright test');
            await this.createPlaywrightCheck(playwrightCheck, playwrightConfigPath);
            return;
        }
        const location = await (0, test_helper_1.prepareRunLocation)(checklyConfig.cli, {
            runLocation: runLocation,
            privateRunLocation,
        }, api, config_1.default.getAccountId());
        const reporterTypes = (0, test_helper_1.prepareReportersTypes)(reporterFlag, checklyConfig.cli?.reporters);
        const { data: account } = await api.accounts.get(config_1.default.getAccountId());
        const { data: availableRuntimes } = await api.runtimes.getAll();
        const testEnvVars = await (0, util_1.getEnvs)(envFile, env);
        const project = await (0, project_parser_1.parseProject)({
            directory: configDirectory,
            projectLogicalId: checklyConfig.logicalId,
            projectName: testSessionName ?? checklyConfig.projectName,
            repoUrl: checklyConfig.repoUrl,
            includeTestOnlyChecks: true,
            availableRuntimes: availableRuntimes.reduce((acc, runtime) => {
                acc[runtime.name] = runtime;
                return acc;
            }, {}),
            defaultRuntimeId: account.runtimeId,
            verifyRuntimeDependencies: false,
            checklyConfigConstructs,
            playwrightConfigPath,
            include: checklyConfig.checks?.include,
            playwrightChecks: [playwrightCheck],
            checkFilter: check => {
                // Skip non Playwright checks
                if (!(check instanceof constructs_1.PlaywrightCheck)) {
                    return false;
                }
                if (check instanceof constructs_1.RuntimeCheck) {
                    if (Object.keys(testEnvVars).length) {
                        check.environmentVariables = check.environmentVariables
                            ?.filter((envVar) => !testEnvVars[envVar.key]) || [];
                        for (const [key, value] of Object.entries(testEnvVars)) {
                            check.environmentVariables.push({
                                key,
                                value,
                                locked: true,
                            });
                        }
                    }
                }
                return true;
            },
        });
        this.style.actionSuccess();
        this.style.actionStart('Validating project resources');
        const diagnostics = new constructs_1.Diagnostics();
        await project.validate(diagnostics);
        for (const diag of diagnostics.observations) {
            if (diag.isFatal()) {
                this.style.longError(diag.title, diag.message);
            }
            else if (!diag.isBenign()) {
                this.style.longWarning(diag.title, diag.message);
            }
            else {
                this.style.longInfo(diag.title, diag.message);
            }
        }
        if (diagnostics.isFatal()) {
            this.style.actionFailure();
            this.style.shortError(`Unable to continue due to unresolved validation errors.`);
            this.exit(1);
        }
        this.style.actionSuccess();
        this.style.actionStart('Bundling project resources');
        const projectBundle = await (async () => {
            try {
                const bundle = await project.bundle();
                this.style.actionSuccess();
                return bundle;
            }
            catch (err) {
                this.style.actionFailure();
                throw err;
            }
        })();
        const checkBundles = Object.values(projectBundle.data.check);
        if (!checkBundles.length) {
            this.log(`Unable to find checks to run`);
            return;
        }
        const reporters = (0, reporter_1.createReporters)(reporterTypes, location, verboseFlag);
        const repoInfo = (0, util_1.getGitInformation)(project.repoUrl);
        const ciInfo = (0, util_1.getCiInformation)();
        // TODO: ADD PROPER RETRY STRATEGY HANDLING
        // const testRetryStrategy = this.prepareTestRetryStrategy(retries, checklyConfig?.cli?.retries)
        const runner = new test_runner_1.default(config_1.default.getAccountId(), projectBundle, checkBundles, constructs_1.Session.sharedFiles, location, timeout, verboseFlag, record, repoInfo, ciInfo.environment, 
        // NO NEED TO UPLOAD SNAPSHOTS FOR PLAYWRIGHT TESTS
        false, configDirectory, 
        // TODO: ADD PROPER RETRY STRATEGY HANDLING
        null);
        runner.on(abstract_check_runner_1.Events.RUN_STARTED, (checks, testSessionId) => reporters.forEach(r => r.onBegin(checks, testSessionId)));
        runner.on(abstract_check_runner_1.Events.CHECK_INPROGRESS, (check, sequenceId) => {
            reporters.forEach(r => r.onCheckInProgress(check, sequenceId));
        });
        runner.on(abstract_check_runner_1.Events.MAX_SCHEDULING_DELAY_EXCEEDED, () => {
            reporters.forEach(r => r.onSchedulingDelayExceeded());
        });
        runner.on(abstract_check_runner_1.Events.CHECK_ATTEMPT_RESULT, (sequenceId, check, result, links) => {
            reporters.forEach(r => r.onCheckAttemptResult(sequenceId, {
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                ...result,
            }, links));
        });
        runner.on(abstract_check_runner_1.Events.CHECK_SUCCESSFUL, (sequenceId, check, result, testResultId, links) => {
            if (result.hasFailures) {
                process.exitCode = 1;
            }
            reporters.forEach(r => r.onCheckEnd(sequenceId, {
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                ...result,
            }, testResultId, links));
        });
        runner.on(abstract_check_runner_1.Events.CHECK_FAILED, (sequenceId, check, message) => {
            reporters.forEach(r => r.onCheckEnd(sequenceId, {
                ...check,
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                hasFailures: true,
                runError: message,
            }));
            process.exitCode = 1;
        });
        runner.on(abstract_check_runner_1.Events.RUN_FINISHED, () => reporters.forEach(r => r.onEnd()));
        runner.on(abstract_check_runner_1.Events.ERROR, err => {
            reporters.forEach(r => r.onError(err));
            process.exitCode = 1;
        });
        await runner.run();
    }
    static async createPlaywrightCheck(args, runLocation, privateRunLocation, dir) {
        const parseArgs = args.map(arg => {
            if (arg.includes(' ')) {
                arg = `"${arg}"`;
            }
            return arg;
        });
        const input = parseArgs.join(' ') || '';
        const inputLogicalId = (0, sourcegen_1.cased)(input, 'kebab-case').substring(0, 50);
        const testCommand = await PwTestCommand.getTestCommand(dir, input);
        // Use private location if provided, otherwise use public location (with default if neither is provided)
        const locationConfig = privateRunLocation
            ? { privateLocations: [privateRunLocation] }
            : { locations: [runLocation || constants_1.DEFAULT_REGION] };
        return {
            logicalId: `playwright-check-${inputLogicalId}`,
            name: `Playwright Test: ${input}`,
            testCommand,
            ...locationConfig,
            frequency: 10,
        };
    }
    getConfigPath(playwrightFlags) {
        for (let i = 0; i < playwrightFlags.length; i++) {
            const arg = playwrightFlags[i];
            if (arg.startsWith('--config') || arg.startsWith('-c')) {
                return arg.includes('=') ? arg.split('=')[1] : playwrightFlags[i + 1];
            }
        }
    }
    async createPlaywrightCheck(playwrightCheck, playwrightConfigPath = './playwright.config.ts') {
        const dir = process.cwd();
        const baseName = node_path_1.default.basename(dir);
        const configFile = await (0, checkly_config_loader_1.getChecklyConfigFile)();
        if (!configFile) {
            this.style.shortWarning('No Checkly config file found');
            this.style.shortInfo('Creating a default checkly config file.');
            const checklyConfig = (0, util_1.getDefaultChecklyConfig)(baseName, `./${node_path_1.default.relative(dir, playwrightConfigPath)}`, playwrightCheck);
            await (0, util_1.writeChecklyConfigFile)(dir, checklyConfig);
            this.style.actionSuccess();
            return;
        }
        const checklyAst = recast.parse(configFile.checklyConfig);
        const checksAst = (0, write_config_helpers_1.findPropertyByName)(checklyAst, 'checks');
        if (!checksAst) {
            this.style.longError('Unable to automatically sync your config file.', 'This can happen if your Checkly config is '
                + 'built using helper functions or other JS/TS features. You can still manually set Playwright config values in '
                + 'your Checkly config: https://www.checklyhq.com/docs/cli/constructs-reference/#project');
            return;
        }
        const b = recast.types.builders;
        const playwrightPropertyNode = b.property('init', b.identifier('playwrightConfigPath'), b.stringLiteral(playwrightConfigPath));
        const playwrightCheckString = `const playwrightCheck = ${JSON5.stringify(playwrightCheck, { space: 2 })}`;
        const playwrightCheckAst = recast.parse(playwrightCheckString);
        const playwrightCheckNode = playwrightCheckAst.program.body[0].declarations[0].init;
        (0, write_config_helpers_1.addOrReplaceItem)(checksAst.value, playwrightPropertyNode, 'playwrightConfigPath');
        (0, write_config_helpers_1.addItemToArray)(checksAst.value, playwrightCheckNode, 'playwrightChecks');
        const checklyConfigData = recast.print(checklyAst, { tabWidth: 2 }).code;
        const writeDir = node_path_1.default.resolve(node_path_1.default.dirname(configFile.fileName));
        await (0, write_config_helpers_1.reWriteChecklyConfigFile)(checklyConfigData, configFile.fileName, writeDir);
        this.style.actionSuccess();
        return;
    }
    static async getTestCommand(directoryPath, input) {
        const packageManager = await (0, package_manager_1.detectPackageManager)(directoryPath);
        // Passing the input to the execCommand will return it quoted, which we want to avoid
        return `${packageManager.execCommand(['playwright', 'test']).unsafeDisplayCommand} ${input}`;
    }
}
exports.default = PwTestCommand;
//# sourceMappingURL=pw-test.js.map