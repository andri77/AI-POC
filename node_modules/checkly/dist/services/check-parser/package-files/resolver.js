"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageFilesResolver = void 0;
const node_path_1 = __importDefault(require("node:path"));
const source_file_1 = require("./source-file");
const package_json_file_1 = require("./package-json-file");
const tsconfig_json_file_1 = require("./tsconfig-json-file");
const jsconfig_json_file_1 = require("./jsconfig-json-file");
const paths_1 = require("./paths");
const loader_1 = require("./loader");
const json_source_file_1 = require("./json-source-file");
const lookup_1 = require("./lookup");
class PackageFilesCache {
    #sourceFileCache = new loader_1.FileLoader(source_file_1.SourceFile.loadFromFilePath);
    #jsonFileLoader(load) {
        return async (filePath) => {
            const sourceFile = await this.#sourceFileCache.load(filePath);
            if (sourceFile === undefined) {
                return;
            }
            const jsonFile = json_source_file_1.JsonSourceFile.loadFromSourceFile(sourceFile);
            if (jsonFile === undefined) {
                return;
            }
            return load(jsonFile);
        };
    }
    #packageJsonCache = new loader_1.FileLoader(this.#jsonFileLoader(package_json_file_1.PackageJsonFile.loadFromJsonSourceFile));
    #tsconfigJsonCache = new loader_1.FileLoader(this.#jsonFileLoader(tsconfig_json_file_1.TSConfigFile.loadFromJsonSourceFile));
    #jsconfigJsonCache = new loader_1.FileLoader(this.#jsonFileLoader(jsconfig_json_file_1.JSConfigFile.loadFromJsonSourceFile));
    async sourceFile(filePath, context) {
        for (const lookupPath of context.collectLookupPaths(filePath)) {
            const sourceFile = await this.#sourceFileCache.load(lookupPath);
            if (sourceFile === undefined) {
                continue;
            }
            return sourceFile;
        }
    }
    async packageJson(filePath) {
        return await this.#packageJsonCache.load(filePath);
    }
    async tsconfigJson(filePath) {
        return await this.#tsconfigJsonCache.load(filePath);
    }
    async jsconfigJson(filePath) {
        return await this.#jsconfigJsonCache.load(filePath);
    }
}
class PackageFiles {
    packageJson;
    tsconfigJson;
    jsconfigJson;
    async satisfyFromDirPath(dirPath, cache) {
        if (this.packageJson === undefined) {
            this.packageJson = await cache.packageJson(package_json_file_1.PackageJsonFile.filePath(dirPath));
        }
        if (this.tsconfigJson === undefined && this.jsconfigJson === undefined) {
            this.tsconfigJson = await cache.tsconfigJson(tsconfig_json_file_1.TSConfigFile.filePath(dirPath));
        }
        if (this.jsconfigJson === undefined && this.tsconfigJson === undefined) {
            this.jsconfigJson = await cache.jsconfigJson(jsconfig_json_file_1.JSConfigFile.filePath(dirPath));
        }
        return this.satisfied;
    }
    get satisfied() {
        // Never satisfied until we find a package.json file.
        if (this.packageJson === undefined) {
            return false;
        }
        // Not satisfied until either a tsconfig.json or a jsconfig.json file
        // is found.
        if (this.tsconfigJson === undefined && this.jsconfigJson === undefined) {
            return false;
        }
        return true;
    }
}
async function walkUp(filePath, find, options) {
    let currentPath = filePath;
    if (options?.isDir === true) {
        // To keep things simple, just add a dummy component.
        currentPath = node_path_1.default.join(currentPath, 'z');
    }
    while (true) {
        const prevPath = currentPath;
        currentPath = node_path_1.default.dirname(prevPath);
        // Bail out if we reach root.
        if (prevPath === currentPath) {
            break;
        }
        const found = await find(currentPath);
        if (found) {
            return true;
        }
        // Stop if we reach the user-specified root directory.
        // TODO: I don't like a string comparison for this but it'll do for now.
        if (currentPath === options?.root) {
            break;
        }
    }
    return false;
}
class PackageFilesResolver {
    cache = new PackageFilesCache();
    async loadPackageJsonFile(filePath, options) {
        let packageJson;
        await walkUp(filePath, async (dirPath) => {
            packageJson = await this.cache.packageJson(package_json_file_1.PackageJsonFile.filePath(dirPath));
            return packageJson !== undefined;
        }, options);
        return packageJson;
    }
    async loadPackageFiles(filePath, options) {
        const files = new PackageFiles();
        await walkUp(filePath, async (dirPath) => {
            const found = await files.satisfyFromDirPath(dirPath, this.cache);
            return found;
        }, options);
        return files;
    }
    async resolveSourceFile(sourceFile, context) {
        if (sourceFile.meta.basename === package_json_file_1.PackageJsonFile.FILENAME) {
            const packageJson = await this.cache.packageJson(sourceFile.meta.filePath);
            if (packageJson === undefined) {
                // This should never happen unless the package.json is invalid or
                // something.
                return [sourceFile];
            }
            // Go through each main path. A fallback path is included. If we can
            // find a tsconfig for the main file, look it up and attempt to find
            // the original TypeScript sources roughly the same way tsc does it.
            for (const mainPath of packageJson.mainPaths) {
                const { tsconfigJson, jsconfigJson } = await this.loadPackageFiles(mainPath, {
                    root: packageJson.basePath,
                });
                // TODO: Prefer jsconfig.json when dealing with a JavaScript file.
                for (const configJson of [tsconfigJson, jsconfigJson]) {
                    if (configJson === undefined) {
                        continue;
                    }
                    const candidatePaths = configJson.collectLookupPaths(mainPath).flatMap(filePath => {
                        return context.collectLookupPaths(filePath);
                    });
                    for (const candidatePath of candidatePaths) {
                        const mainSourceFile = await this.cache.sourceFile(candidatePath, context);
                        if (mainSourceFile === undefined) {
                            continue;
                        }
                        configJson.registerRelatedSourceFile(mainSourceFile);
                        return [sourceFile, mainSourceFile, configJson.jsonFile.sourceFile];
                    }
                }
                const mainSourceFile = await this.cache.sourceFile(mainPath, context);
                if (mainSourceFile === undefined) {
                    continue;
                }
                return [sourceFile, mainSourceFile];
            }
            // TODO: Is this even useful without any code files?
            return [sourceFile];
        }
        return [sourceFile];
    }
    async resolveDependenciesForFilePath(filePath, dependencies) {
        const resolved = {
            external: [],
            missing: [],
            local: [],
        };
        const dirname = node_path_1.default.dirname(filePath);
        const { tsconfigJson, jsconfigJson } = await this.loadPackageFiles(filePath);
        const context = lookup_1.LookupContext.forFilePath(filePath);
        resolve: for (const importPath of dependencies) {
            if ((0, paths_1.isBuiltinPath)(importPath)) {
                resolved.external.push({
                    importPath,
                });
                continue resolve;
            }
            if ((0, paths_1.isLocalPath)(importPath)) {
                const relativeDepPath = node_path_1.default.resolve(dirname, importPath);
                const sourceFile = await this.cache.sourceFile(relativeDepPath, context);
                if (sourceFile !== undefined) {
                    const resolvedFiles = await this.resolveSourceFile(sourceFile, context);
                    let found = false;
                    for (const resolvedFile of resolvedFiles) {
                        resolved.local.push({
                            kind: 'relative-path',
                            importPath,
                            sourceFile: resolvedFile,
                        });
                        found = true;
                    }
                    if (found) {
                        continue resolve;
                    }
                }
                resolved.missing.push({
                    importPath,
                    filePath: relativeDepPath,
                });
                continue resolve;
            }
            for (const configJson of [tsconfigJson, jsconfigJson]) {
                if (configJson === undefined) {
                    continue;
                }
                const resolvedPaths = configJson.resolvePath(importPath);
                if (resolvedPaths.length > 0) {
                    let found = false;
                    for (const { source, target } of resolvedPaths) {
                        const relativePath = node_path_1.default.resolve(configJson.basePath, target.path);
                        const sourceFile = await this.cache.sourceFile(relativePath, context);
                        if (sourceFile !== undefined) {
                            const resolvedFiles = await this.resolveSourceFile(sourceFile, context);
                            for (const resolvedFile of resolvedFiles) {
                                configJson.registerRelatedSourceFile(resolvedFile);
                                resolved.local.push({
                                    kind: 'tsconfig-resolved-path',
                                    importPath,
                                    sourceFile: resolvedFile,
                                    configFile: configJson,
                                    pathResult: {
                                        source,
                                        target,
                                    },
                                });
                                resolved.local.push({
                                    kind: 'tsconfig-file',
                                    importPath,
                                    sourceFile: configJson.jsonFile.sourceFile,
                                    configFile: configJson,
                                });
                                found = true;
                            }
                            if (found) {
                                // We're trying to find the first match out of many possible
                                // candidates. Stop once we find a match.
                                break;
                            }
                        }
                    }
                    if (found) {
                        continue resolve;
                    }
                }
                if (configJson.baseUrl !== undefined) {
                    const relativePath = node_path_1.default.resolve(configJson.basePath, configJson.baseUrl, importPath);
                    const sourceFile = await this.cache.sourceFile(relativePath, context);
                    if (sourceFile !== undefined) {
                        const resolvedFiles = await this.resolveSourceFile(sourceFile, context);
                        let found = false;
                        for (const resolvedFile of resolvedFiles) {
                            configJson.registerRelatedSourceFile(resolvedFile);
                            resolved.local.push({
                                kind: 'tsconfig-baseurl-relative-path',
                                importPath,
                                sourceFile: resolvedFile,
                                configFile: configJson,
                            });
                            resolved.local.push({
                                kind: 'tsconfig-file',
                                importPath,
                                sourceFile: configJson.jsonFile.sourceFile,
                                configFile: configJson,
                            });
                            found = true;
                        }
                        if (found) {
                            continue resolve;
                        }
                    }
                }
            }
            resolved.external.push({
                importPath,
            });
        }
        return resolved;
    }
}
exports.PackageFilesResolver = PackageFilesResolver;
//# sourceMappingURL=resolver.js.map