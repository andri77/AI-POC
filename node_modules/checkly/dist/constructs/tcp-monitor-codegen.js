"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TcpMonitorCodegen = exports.valueForTcpAssertion = void 0;
const codegen_1 = require("./internal/codegen");
const sourcegen_1 = require("../sourcegen");
const monitor_codegen_1 = require("./monitor-codegen");
const assertion_codegen_1 = require("./internal/assertion-codegen");
function valueForTcpAssertion(genfile, assertion) {
    genfile.namedImport('TcpAssertionBuilder', 'checkly/constructs');
    switch (assertion.source) {
        case 'RESPONSE_DATA':
            return (0, assertion_codegen_1.valueForGeneralAssertion)('TcpAssertionBuilder', 'responseData', assertion);
        case 'RESPONSE_TIME':
            return (0, assertion_codegen_1.valueForNumericAssertion)('TcpAssertionBuilder', 'responseTime', assertion);
        default:
            throw new Error(`Unsupported TCP assertion source ${assertion.source}`);
    }
}
exports.valueForTcpAssertion = valueForTcpAssertion;
const construct = 'TcpMonitor';
class TcpMonitorCodegen extends codegen_1.Codegen {
    describe(resource) {
        return `TCP Monitor: ${resource.name}`;
    }
    gencode(logicalId, resource, context) {
        const filePath = context.filePath('resources/tcp-monitors', resource.name, {
            tags: resource.tags,
            unique: true,
        });
        const file = this.program.generatedConstructFile(filePath.fullPath);
        file.namedImport(construct, 'checkly/constructs');
        file.section((0, sourcegen_1.expr)((0, sourcegen_1.ident)(construct), builder => {
            builder.new(builder => {
                builder.string(logicalId);
                builder.object(builder => {
                    builder.object('request', builder => {
                        builder.string('hostname', resource.request.hostname);
                        builder.number('port', resource.request.port);
                        if (resource.request.ipFamily) {
                            builder.string('ipFamily', resource.request.ipFamily);
                        }
                        if (resource.request.data) {
                            builder.string('data', resource.request.data);
                        }
                        if (resource.request.assertions) {
                            const assertions = resource.request.assertions;
                            if (assertions.length > 0) {
                                builder.array('assertions', builder => {
                                    for (const assertion of assertions) {
                                        builder.value(valueForTcpAssertion(file, assertion));
                                    }
                                });
                            }
                        }
                    });
                    if (resource.degradedResponseTime !== undefined) {
                        builder.number('degradedResponseTime', resource.degradedResponseTime);
                    }
                    if (resource.maxResponseTime !== undefined) {
                        builder.number('maxResponseTime', resource.maxResponseTime);
                    }
                    (0, monitor_codegen_1.buildMonitorProps)(this.program, file, builder, resource, context);
                });
            });
        }));
    }
}
exports.TcpMonitorCodegen = TcpMonitorCodegen;
//# sourceMappingURL=tcp-monitor-codegen.js.map