"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.Project = void 0;
const node_path_1 = __importDefault(require("node:path"));
const api = __importStar(require("../rest/api"));
const parser_1 = require("../services/check-parser/parser");
const construct_1 = require("./construct");
const validator_error_1 = require("./validator-error");
const _1 = require("./");
const loader_1 = require("../loader");
const construct_diagnostics_1 = require("./construct-diagnostics");
const project_bundle_1 = require("./project-bundle");
const util_1 = require("../services/util");
class Project extends construct_1.Construct {
    name;
    repoUrl;
    logicalId;
    testOnlyAllowed = false;
    data = {
        'check': {},
        'check-group': {},
        'alert-channel': {},
        'alert-channel-subscription': {},
        'maintenance-window': {},
        'private-location': {},
        'private-location-check-assignment': {},
        'private-location-group-assignment': {},
        'dashboard': {},
        'status-page': {},
        'status-page-service': {},
    };
    static __checklyType = 'project';
    /**
     * Constructs the Project instance
     *
     * @param logicalId unique project identifier
     * @param props project configuration properties
     */
    constructor(logicalId, props) {
        super(Project.__checklyType, logicalId);
        this.name = props.name;
        this.repoUrl = props.repoUrl;
        this.logicalId = logicalId;
    }
    describe() {
        return `Project:${this.logicalId}`;
    }
    async validate(diagnostics) {
        await super.validate(diagnostics);
        if (!this.name) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('name', new Error(`Value must not be empty.`)));
        }
        const data = this.data;
        const constructDiagnostics = await Promise.all(Object.entries(data).flatMap(([, records]) => {
            return Object.values(records).map(async (construct) => {
                const diagnostics = new construct_diagnostics_1.ConstructDiagnostics(construct);
                await construct.validate(diagnostics);
                return diagnostics;
            });
        }));
        diagnostics.extend(...constructDiagnostics);
    }
    allowTestOnly(enabled) {
        this.testOnlyAllowed = enabled;
    }
    addResource(type, logicalId, resource) {
        const existingResource = this.data[type][logicalId];
        if (existingResource) {
            // Non-member resources (i.e. references) can be used multiple times.
            // Behind the scenes, we'll create a single mapping for them, and the
            // referenced resource isn't managed by the project at all.
            if (!resource.member && !existingResource.member && existingResource.physicalId === resource.physicalId) {
                return;
            }
            throw new Error(`Resource of type '${type}' with logical id '${logicalId}' already exists.`);
        }
        this.data[type][logicalId] = resource;
    }
    async bundle() {
        const data = {
            ...this.data,
            // Filter out testOnly checks before bundling.
            check: Object.fromEntries(Object.entries(this.data.check)
                .filter(([, check]) => !check.testOnly || this.testOnlyAllowed)
                .filter(([, check]) => Session.checkFilter?.(check) ?? true)),
        };
        const constructBundles = await Promise.all(Object.entries(data).flatMap(([, records]) => {
            return Object.entries(records).map(async ([, construct]) => {
                const bundle = await construct.bundle();
                return {
                    construct,
                    bundle,
                };
            });
        }));
        const dataBundle = Object.fromEntries(Object.entries(data).map(([type]) => {
            return [type, {}];
        }));
        for (const constructBundle of constructBundles) {
            const { construct: { type, logicalId } } = constructBundle;
            dataBundle[type][logicalId] = constructBundle;
        }
        return new project_bundle_1.ProjectBundle(this, dataBundle);
    }
    synthesize() {
        const project = {
            logicalId: this.logicalId,
            name: this.name,
            repoUrl: this.repoUrl,
        };
        return {
            project,
            sharedFiles: Session.sharedFiles,
        };
    }
    getTestOnlyConstructs() {
        return Object
            .values(this.data)
            .flatMap((record) => Object
            .values(record)
            .filter((construct) => construct instanceof _1.Check && construct.testOnly));
    }
    getHeartbeatLogicalIds() {
        return Object
            .values(this.data.check)
            .filter((construct) => construct instanceof _1.HeartbeatMonitor)
            .map((construct) => construct.logicalId);
    }
}
exports.Project = Project;
class Session {
    static loader = new loader_1.MixedFileLoader(new loader_1.NativeFileLoader(), new loader_1.JitiFileLoader(), new loader_1.TSNodeFileLoader());
    static project;
    static basePath;
    static checkDefaults;
    static checkFilter;
    static browserCheckDefaults;
    static multiStepCheckDefaults;
    static checkFilePath;
    static checkFileAbsolutePath;
    static availableRuntimes;
    static defaultRuntimeId;
    static verifyRuntimeDependencies = true;
    static loadingChecklyConfigFile;
    static checklyConfigFileConstructs;
    static privateLocations;
    static parsers = new Map();
    static constructExports = [];
    static async loadFile(filePath) {
        const loader = this.loader;
        if (loader === undefined) {
            throw new Error(`Session has no loader set`);
        }
        if (!loader.isAuthoritativeFor(filePath)) {
            throw new Error(`Unable to find a compatible loader for file '${filePath}'`);
        }
        try {
            const moduleExports = await loader.loadFile(filePath);
            // Register all exported constructs we find.
            for (const [exportName, value] of Object.entries(moduleExports ?? {})) {
                if (value instanceof construct_1.Construct) {
                    this.constructExports.push({
                        type: value.type,
                        logicalId: value.logicalId,
                        filePath,
                        exportName,
                    });
                }
            }
            const defaultExport = moduleExports?.default ?? moduleExports;
            if (typeof defaultExport === 'function') {
                return await defaultExport();
            }
            return defaultExport;
        }
        catch (err) {
            throw new Error(`Error loading file '${filePath}'\n${err.stack}`);
        }
    }
    static registerConstruct(construct) {
        if (Session.project) {
            Session.project.addResource(construct.type, construct.logicalId, construct);
        }
        else if (Session.loadingChecklyConfigFile && construct.allowInChecklyConfig()) {
            Session.checklyConfigFileConstructs.push(construct);
        }
        else {
            throw new Error('Internal Error: Session is not properly configured for using a construct. Please contact Checkly support at support@checklyhq.com.');
        }
    }
    static validateCreateConstruct(construct) {
        if (typeof construct.logicalId !== 'string') {
            throw new validator_error_1.ValidationError(`The "logicalId" of a construct must be a string (logicalId=${construct.logicalId} [${typeof construct.logicalId}])`);
        }
        if (!/^[A-Za-z0-9_\-/#.]+$/.test(construct.logicalId)) {
            throw new validator_error_1.ValidationError(`The "logicalId" can only include the following characters: [A-Za-z0-9_-/#.]. (logicalId='${construct.logicalId}')`);
        }
        if (construct.type === Project.__checklyType) {
            // Creating the construct is allowed - We're creating the project.
        }
        else if (Session.project) {
            // Creating the construct is allowed - We're in the process of parsing the project.
        }
        else if (Session.loadingChecklyConfigFile && construct.allowInChecklyConfig()) {
            // Creating the construct is allowed - We're in the process of parsing the Checkly config.
        }
        else if (Session.loadingChecklyConfigFile) {
            throw new Error(`Creating a ${construct.constructor.name} construct in the Checkly config file isn't supported.`);
        }
        else {
            throw new Error(`Unable to create a construct '${construct.constructor.name}' outside a Checkly CLI project.`);
        }
    }
    static async getPrivateLocations() {
        if (!Session.privateLocations) {
            const { data: privateLocations } = await api.privateLocations.getAll();
            Session.privateLocations = privateLocations;
        }
        return Session.privateLocations;
    }
    static getRuntime(runtimeId) {
        const effectiveRuntimeId = runtimeId ?? Session.defaultRuntimeId;
        if (effectiveRuntimeId === undefined) {
            throw new Error('Internal Error: Account default runtime is not set. Please contact Checkly support at support@checklyhq.com.');
        }
        return Session.availableRuntimes[effectiveRuntimeId];
    }
    static getParser(runtime) {
        const cachedParser = Session.parsers.get(runtime.name);
        if (cachedParser !== undefined) {
            return cachedParser;
        }
        const parser = new parser_1.Parser({
            supportedNpmModules: Object.keys(runtime.dependencies),
            checkUnsupportedModules: Session.verifyRuntimeDependencies,
        });
        Session.parsers.set(runtime.name, parser);
        return parser;
    }
    static relativePosixPath(filePath) {
        return (0, util_1.pathToPosix)(node_path_1.default.relative(Session.basePath, filePath));
    }
    static sharedFileRefs = new Map();
    static sharedFiles = [];
    static registerSharedFile(file) {
        const ref = Session.sharedFileRefs.get(file.path);
        if (ref !== undefined) {
            return ref;
        }
        const newRef = Session.sharedFiles.push(file) - 1;
        Session.sharedFileRefs.set(file.path, newRef);
        return newRef;
    }
    static resetSharedFiles() {
        Session.sharedFileRefs.clear();
        Session.sharedFiles.splice(0);
    }
}
exports.Session = Session;
//# sourceMappingURL=project.js.map