"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiCheck = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const check_1 = require("./check");
const project_1 = require("./project");
const construct_1 = require("./construct");
const construct_diagnostics_1 = require("./construct-diagnostics");
const api_check_bundle_1 = require("./api-check-bundle");
const common_diagnostics_1 = require("./internal/common-diagnostics");
/**
 * Creates an API Check to monitor HTTP endpoints and APIs.
 *
 * API checks allow you to monitor REST APIs, GraphQL endpoints, and any HTTP-based service.
 * You can validate response status codes, response times, headers, and response body content.
 *
 * @example
 * ```typescript
 * // Basic API check
 * new ApiCheck('hello-api', {
 *   name: 'Hello API',
 *   request: {
 *     method: 'GET',
 *     url: 'https://api.example.com/hello',
 *     assertions: [
 *       AssertionBuilder.statusCode().equals(200)
 *     ]
 *   }
 * })
 *
 * // Advanced API check with POST request
 * new ApiCheck('user-api', {
 *   name: 'User API Check',
 *   frequency: Frequency.EVERY_5M,
 *   locations: ['us-east-1', 'eu-west-1'],
 *   request: {
 *     method: 'POST',
 *     url: 'https://api.example.com/users',
 *     headers: [{ key: 'Content-Type', value: 'application/json' }],
 *     body: JSON.stringify({ name: 'test-user' }),
 *     bodyType: 'JSON',
 *     assertions: [
 *       AssertionBuilder.statusCode().equals(201),
 *       AssertionBuilder.jsonBody('$.id').isNotNull(),
 *       AssertionBuilder.responseTime().lessThan(1000)
 *     ]
 *   },
 *   maxResponseTime: 5000,
 *   degradedResponseTime: 2000
 * })
 *
 * // Error validation check (shouldFail required for error status checks)
 * new ApiCheck('not-found-check', {
 *   name: 'Not Found Check',
 *   shouldFail: true,
 *   request: {
 *     method: 'GET',
 *     url: 'https://api.example.com/nonexistent',
 *     assertions: [
 *       AssertionBuilder.statusCode().equals(404)
 *     ]
 *   }
 * })
 * ```
 *
 * @see {@link https://www.checklyhq.com/docs/cli/constructs-reference/#apicheck | ApiCheck API Reference}
 * @see {@link https://www.checklyhq.com/docs/monitoring/api-checks/ | API Checks Documentation}
 */
/**
 * Creates an API Check to monitor HTTP endpoints and APIs.
 *
 * API checks allow you to monitor REST APIs, GraphQL endpoints, and any HTTP-based service.
 * You can validate response status codes, response times, headers, and response body content.
 *
 * @example
 * ```typescript
 * // Basic API check
 * new ApiCheck('hello-api', {
 *   name: 'Hello API',
 *   request: {
 *     method: 'GET',
 *     url: 'https://api.example.com/hello',
 *     assertions: [
 *       AssertionBuilder.statusCode().equals(200)
 *     ]
 *   }
 * })
 *
 * // Advanced API check with POST request
 * new ApiCheck('user-api', {
 *   name: 'User API Check',
 *   frequency: Frequency.EVERY_5M,
 *   locations: ['us-east-1', 'eu-west-1'],
 *   request: {
 *     method: 'POST',
 *     url: 'https://api.example.com/users',
 *     headers: [{ key: 'Content-Type', value: 'application/json' }],
 *     body: JSON.stringify({ name: 'test-user' }),
 *     bodyType: 'JSON',
 *     assertions: [
 *       AssertionBuilder.statusCode().equals(201),
 *       AssertionBuilder.jsonBody('$.id').isNotNull(),
 *       AssertionBuilder.responseTime().lessThan(1000)
 *     ]
 *   },
 *   maxResponseTime: 5000,
 *   degradedResponseTime: 2000
 * })
 *
 * // Error validation check (shouldFail required for error status checks)
 * new ApiCheck('not-found-check', {
 *   name: 'Not Found Check',
 *   shouldFail: true,
 *   request: {
 *     method: 'GET',
 *     url: 'https://api.example.com/nonexistent',
 *     assertions: [
 *       AssertionBuilder.statusCode().equals(404)
 *     ]
 *   }
 * })
 * ```
 *
 * @see {@link https://www.checklyhq.com/docs/cli/constructs-reference/#apicheck | ApiCheck API Reference}
 * @see {@link https://www.checklyhq.com/docs/monitoring/api-checks/ | API Checks Documentation}
 */
class ApiCheck extends check_1.RuntimeCheck {
    request;
    localSetupScript;
    setupScript;
    localTearDownScript;
    tearDownScript;
    degradedResponseTime;
    maxResponseTime;
    /**
     * Constructs the API Check instance
     *
     * @param logicalId unique project-scoped resource name identification
     * @param props check configuration properties
     *
     * {@link https://checklyhq.com/docs/cli/constructs-reference/#apicheck Read more in the docs}
     */
    constructor(logicalId, props) {
        super(logicalId, props);
        this.setupScript = props.setupScript;
        this.localSetupScript = props.localSetupScript;
        this.tearDownScript = props.tearDownScript;
        this.localTearDownScript = props.localTearDownScript;
        this.request = props.request;
        this.degradedResponseTime = props.degradedResponseTime;
        this.maxResponseTime = props.maxResponseTime;
        project_1.Session.registerConstruct(this);
        this.addSubscriptions();
        this.addPrivateLocationCheckAssignments();
    }
    describe() {
        return `ApiCheck:${this.logicalId}`;
    }
    supportsOnlyOnNetworkErrorRetryStrategy() {
        return true;
    }
    async validate(diagnostics) {
        await super.validate(diagnostics);
        if (this.setupScript) {
            if (!(0, construct_1.isEntrypoint)(this.setupScript) && !(0, construct_1.isContent)(this.setupScript)) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('setupScript', new Error(`Either "entrypoint" or "content" is required.`)));
            }
            else if ((0, construct_1.isEntrypoint)(this.setupScript) && (0, construct_1.isContent)(this.setupScript)) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('setupScript', new Error(`Provide exactly one of "entrypoint" or "content", but not both.`)));
            }
            else if ((0, construct_1.isEntrypoint)(this.setupScript)) {
                const entrypoint = this.resolveContentFilePath(this.setupScript.entrypoint);
                try {
                    await promises_1.default.access(entrypoint, promises_1.default.constants.R_OK);
                }
                catch (err) {
                    diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('setupScript', new Error(`Unable to access entrypoint file "${entrypoint}": ${err.message}`, { cause: err })));
                }
            }
        }
        if (this.localSetupScript) {
            diagnostics.add(new construct_diagnostics_1.DeprecatedPropertyDiagnostic('localSetupScript', new Error(`Use "setupScript" instead.`)));
        }
        if (this.tearDownScript) {
            if (!(0, construct_1.isEntrypoint)(this.tearDownScript) && !(0, construct_1.isContent)(this.tearDownScript)) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('tearDownScript', new Error(`Either "entrypoint" or "content" is required.`)));
            }
            else if ((0, construct_1.isEntrypoint)(this.tearDownScript) && (0, construct_1.isContent)(this.tearDownScript)) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('tearDownScript', new Error(`Provide exactly one of "entrypoint" or "content", but not both.`)));
            }
            else if ((0, construct_1.isEntrypoint)(this.tearDownScript)) {
                const entrypoint = this.resolveContentFilePath(this.tearDownScript.entrypoint);
                try {
                    await promises_1.default.access(entrypoint, promises_1.default.constants.R_OK);
                }
                catch (err) {
                    diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('tearDownScript', new Error(`Unable to access entrypoint file "${entrypoint}": ${err.message}`, { cause: err })));
                }
            }
        }
        if (this.localTearDownScript) {
            diagnostics.add(new construct_diagnostics_1.DeprecatedPropertyDiagnostic('localTearDownScript', new Error(`Use "tearDownScript" instead.`)));
        }
        await (0, common_diagnostics_1.validateResponseTimes)(diagnostics, this, {
            degradedResponseTime: 30000,
            maxResponseTime: 30000,
        });
    }
    async bundle() {
        const props = {};
        if (this.localSetupScript) {
            props.localSetupScript = this.localSetupScript;
        }
        if (this.setupScript) {
            if ((0, construct_1.isEntrypoint)(this.setupScript)) {
                const { script, scriptPath, dependencies } = await ApiCheck.bundle(this.resolveContentFilePath(this.setupScript.entrypoint), this.runtimeId);
                props.localSetupScript = script;
                props.setupScriptPath = scriptPath;
                props.setupScriptDependencies = dependencies;
            }
            else {
                props.localSetupScript = this.setupScript.content;
            }
        }
        if (this.localTearDownScript) {
            props.localTearDownScript = this.localTearDownScript;
        }
        if (this.tearDownScript) {
            if ((0, construct_1.isEntrypoint)(this.tearDownScript)) {
                const { script, scriptPath, dependencies } = await ApiCheck.bundle(this.resolveContentFilePath(this.tearDownScript.entrypoint), this.runtimeId);
                props.localTearDownScript = script;
                props.tearDownScriptPath = scriptPath;
                props.tearDownScriptDependencies = dependencies;
            }
            else {
                props.localTearDownScript = this.tearDownScript.content;
            }
        }
        return new api_check_bundle_1.ApiCheckBundle(this, props);
    }
    static async bundle(entrypoint, runtimeId) {
        const runtime = project_1.Session.getRuntime(runtimeId);
        if (!runtime) {
            throw new Error(`${runtimeId} is not supported`);
        }
        const parser = project_1.Session.getParser(runtime);
        const parsed = await parser.parse(entrypoint);
        // Maybe we can get the parsed deps with the content immediately
        const deps = [];
        for (const { filePath, content } of parsed.dependencies) {
            deps.push(project_1.Session.registerSharedFile({
                path: project_1.Session.relativePosixPath(filePath),
                content,
            }));
        }
        return {
            script: parsed.entrypoint.content,
            scriptPath: project_1.Session.relativePosixPath(parsed.entrypoint.filePath),
            dependencies: deps,
        };
    }
    synthesize() {
        return {
            ...super.synthesize(),
            checkType: 'API',
            request: this.request,
            localSetupScript: this.localSetupScript,
            localTearDownScript: this.localTearDownScript,
            degradedResponseTime: this.degradedResponseTime,
            maxResponseTime: this.maxResponseTime,
        };
    }
}
exports.ApiCheck = ApiCheck;
//# sourceMappingURL=api-check.js.map