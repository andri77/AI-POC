"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeCheck = exports.Check = void 0;
const ref_1 = require("./ref");
const frequency_1 = require("./frequency");
const construct_1 = require("./construct");
const alert_channel_subscription_1 = require("./alert-channel-subscription");
const project_1 = require("./project");
const private_location_check_assignment_1 = require("./private-location-check-assignment");
const check_config_1 = require("./check-config");
const common_diagnostics_1 = require("./internal/common-diagnostics");
const construct_diagnostics_1 = require("./construct-diagnostics");
class Check extends construct_1.Construct {
    name;
    activated;
    muted;
    doubleCheck;
    shouldFail;
    locations;
    privateLocations;
    tags;
    frequency;
    frequencyOffset;
    groupId;
    alertChannels;
    testOnly;
    retryStrategy;
    alertSettings;
    useGlobalAlertSettings;
    runParallel;
    triggerIncident;
    __checkFilePath; // internal variable to filter by check file name from the CLI
    static __checklyType = 'check';
    constructor(logicalId, props) {
        super(Check.__checklyType, logicalId);
        const config = this.applyConfigDefaults(props);
        // TODO: Throw an error if required properties are still missing after applying the defaults.
        this.name = config.name;
        this.activated = config.activated;
        this.muted = config.muted;
        this.doubleCheck = config.doubleCheck;
        this.shouldFail = config.shouldFail;
        this.locations = config.locations;
        this.privateLocations = config.privateLocations;
        this.tags = config.tags;
        if (config.frequency instanceof frequency_1.Frequency) {
            this.frequency = config.frequency.frequency;
            this.frequencyOffset = config.frequency.frequencyOffset;
        }
        else {
            this.frequency = config.frequency;
        }
        // Alert channel subscriptions will be synthesized separately in the Project construct.
        // This is due to the way things are organized on the BE.
        this.alertChannels = config.alertChannels ?? [];
        // Prefer the `group` parameter, but support groupId for backwards compatibility.
        this.groupId = config.group?.ref() ?? config.groupId;
        // alertSettings, useGlobalAlertSettings, groupId, groupOrder
        this.testOnly = config.testOnly ?? false;
        this.retryStrategy = config.retryStrategy;
        this.alertSettings = config.alertEscalationPolicy;
        this.useGlobalAlertSettings = !this.alertSettings;
        this.runParallel = config.runParallel ?? false;
        this.triggerIncident = config.triggerIncident;
        this.__checkFilePath = project_1.Session.checkFilePath;
    }
    async validateDoubleCheck(diagnostics) {
        await (0, common_diagnostics_1.validateDeprecatedDoubleCheck)(diagnostics, this);
    }
    // eslint-disable-next-line require-await
    async validateRetryStrategyOnlyOn(diagnostics) {
        if (this.retryStrategy?.onlyOn) {
            if (this.retryStrategy.onlyOn === 'NETWORK_ERROR') {
                if (!this.supportsOnlyOnNetworkErrorRetryStrategy()) {
                    diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('retryStrategy', new Error(`Using "NETWORK_ERROR" with "onlyOn" is only supported in the `
                        + `ApiCheck and UrlMonitor constructs.`)));
                }
            }
            else {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('retryStrategy', new Error(`Unsupported value "${this.retryStrategy.onlyOn}" for "onlyOn".`)));
            }
        }
    }
    supportsOnlyOnNetworkErrorRetryStrategy() {
        return false;
    }
    async validate(diagnostics) {
        await super.validate(diagnostics);
        await this.validateDoubleCheck(diagnostics);
        await this.validateRetryStrategyOnlyOn(diagnostics);
    }
    configDefaultsGetter(props) {
        return (0, check_config_1.makeConfigDefaultsGetter)(props.group?.getCheckDefaults(), project_1.Session.checkDefaults);
    }
    applyConfigDefaults(props) {
        const config = Object.assign({}, props);
        const defaults = this.configDefaultsGetter(props);
        config.activated ??= defaults('activated');
        config.alertChannels ??= defaults('alertChannels');
        config.alertEscalationPolicy ??= defaults('alertEscalationPolicy');
        config.doubleCheck ??= defaults('doubleCheck');
        config.frequency ??= defaults('frequency');
        config.locations ??= defaults('locations');
        config.muted ??= defaults('muted');
        config.privateLocations ??= defaults('privateLocations');
        config.retryStrategy ??= defaults('retryStrategy');
        config.shouldFail ??= defaults('shouldFail');
        config.tags ??= defaults('tags');
        return config;
    }
    /**
     * Creates alert channel subscriptions for this check.
     * Links the check to its configured alert channels to send notifications.
     * Only creates subscriptions if alert channels are configured and check is not test-only.
     */
    addSubscriptions() {
        if (!this.alertChannels || this.testOnly) {
            return;
        }
        for (const alertChannel of this.alertChannels) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const subscription = new alert_channel_subscription_1.AlertChannelSubscription(`check-alert-channel-subscription#${this.logicalId}#${alertChannel.logicalId}`, {
                alertChannelId: ref_1.Ref.from(alertChannel.logicalId),
                checkId: ref_1.Ref.from(this.logicalId),
                activated: true,
            });
        }
    }
    /**
     * Creates private location assignments for this check.
     * Links the check to its configured private locations so it can run on them.
     * Only processes PrivateLocation instances, not string slugs.
     */
    addPrivateLocationCheckAssignments() {
        if (!this.privateLocations) {
            return;
        }
        for (const privateLocation of this.privateLocations) {
            // slugName strings are processed in loadAllPrivateLocations()
            if (typeof privateLocation === 'string') {
                continue;
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const assignment = new private_location_check_assignment_1.PrivateLocationCheckAssignment(`private-location-check-assignment#${this.logicalId}#${privateLocation.logicalId}`, {
                privateLocationId: ref_1.Ref.from(privateLocation.logicalId),
                checkId: ref_1.Ref.from(this.logicalId),
            });
        }
    }
    /**
     * Gets the source file path where this check was defined.
     * Used for filtering and debugging purposes.
     *
     * @returns The absolute path to the check file, or undefined if not set
     */
    getSourceFile() {
        return this.__checkFilePath;
    }
    synthesize() {
        const triggerIncident = (() => {
            if (this.triggerIncident) {
                const { service, ...triggerIncident } = this.triggerIncident;
                return {
                    ...triggerIncident,
                    serviceId: service.ref(),
                };
            }
        })();
        return {
            name: this.name,
            activated: this.activated,
            muted: this.muted,
            shouldFail: this.shouldFail,
            locations: this.locations,
            // private-location instances are assigned with loadAllPrivateLocations()
            privateLocations: undefined,
            tags: this.tags,
            frequency: this.frequency,
            frequencyOffset: this.frequencyOffset,
            // If the check does not belong to a group, we still need to send null
            // to make sure that the group gets unassigned from any group it may
            // already have belonged to.
            groupId: this.groupId ?? null,
            // The backend doesn't actually support the `NO_RETRIES` type, it uses `null` instead.
            retryStrategy: this.retryStrategy?.type === 'NO_RETRIES'
                ? null
                : this.retryStrategy,
            // When `retryStrategy: NO_RETRIES` and `doubleCheck: undefined`, we want to let the user disable all retries.
            // The backend has a Joi default of `doubleCheck: true`, though, so we need special handling for this case.
            doubleCheck: this.doubleCheck === undefined && this.retryStrategy?.type === 'NO_RETRIES'
                ? false
                : this.doubleCheck,
            alertSettings: this.alertSettings,
            useGlobalAlertSettings: this.useGlobalAlertSettings,
            runParallel: this.runParallel,
            triggerIncident,
        };
    }
}
exports.Check = Check;
class RuntimeCheck extends Check {
    runtimeId;
    environmentVariables;
    constructor(logicalId, props) {
        super(logicalId, props);
        const config = this.applyConfigDefaults(props);
        this.runtimeId = config.runtimeId;
        this.environmentVariables = config.environmentVariables ?? [];
    }
    applyConfigDefaults(props) {
        const config = super.applyConfigDefaults(props);
        const defaults = this.configDefaultsGetter(props);
        config.environmentVariables ??= defaults('environmentVariables');
        config.runtimeId ??= defaults('runtimeId');
        return config;
    }
    synthesize() {
        return {
            ...super.synthesize(),
            runtimeId: this.runtimeId,
            environmentVariables: this.environmentVariables,
        };
    }
}
exports.RuntimeCheck = RuntimeCheck;
//# sourceMappingURL=check.js.map