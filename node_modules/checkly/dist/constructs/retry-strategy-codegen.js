"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.valueForRetryStrategy = void 0;
const sourcegen_1 = require("../sourcegen");
function valueForRetryStrategy(genfile, strategy) {
    genfile.namedImport('RetryStrategyBuilder', 'checkly/constructs');
    function buildCommonOptions(options, builder) {
        if (options.baseBackoffSeconds) {
            builder.number('baseBackoffSeconds', options.baseBackoffSeconds);
        }
        if (options.maxRetries) {
            builder.number('maxRetries', options.maxRetries);
        }
        if (options.maxDurationSeconds) {
            builder.number('maxDurationSeconds', options.maxDurationSeconds);
        }
        if (options.sameRegion !== undefined) {
            builder.boolean('sameRegion', options.sameRegion);
        }
        if (options.onlyOn !== undefined) {
            const onlyOn = Array.isArray(options.onlyOn) ? options.onlyOn : [options.onlyOn];
            if (onlyOn.length === 1) {
                builder.string('onlyOn', onlyOn[0]);
            }
            else {
                builder.array('onlyOn', builder => {
                    for (const condition of onlyOn) {
                        builder.string(condition);
                    }
                });
            }
        }
    }
    if (strategy === null || strategy === undefined) {
        return (0, sourcegen_1.expr)((0, sourcegen_1.ident)('RetryStrategyBuilder'), builder => {
            builder.member((0, sourcegen_1.ident)('noRetries'));
            builder.call(builder => {
                builder.empty();
            });
        });
    }
    switch (strategy.type) {
        case 'FIXED':
            return (0, sourcegen_1.expr)((0, sourcegen_1.ident)('RetryStrategyBuilder'), builder => {
                builder.member((0, sourcegen_1.ident)('fixedStrategy'));
                builder.call(builder => {
                    builder.object(builder => {
                        buildCommonOptions(strategy, builder);
                    });
                });
            });
        case 'LINEAR':
            return (0, sourcegen_1.expr)((0, sourcegen_1.ident)('RetryStrategyBuilder'), builder => {
                builder.member((0, sourcegen_1.ident)('linearStrategy'));
                builder.call(builder => {
                    builder.object(builder => {
                        buildCommonOptions(strategy, builder);
                    });
                });
            });
        case 'EXPONENTIAL':
            return (0, sourcegen_1.expr)((0, sourcegen_1.ident)('RetryStrategyBuilder'), builder => {
                builder.member((0, sourcegen_1.ident)('exponentialStrategy'));
                builder.call(builder => {
                    builder.object(builder => {
                        buildCommonOptions(strategy, builder);
                    });
                });
            });
        case 'NO_RETRIES':
            return (0, sourcegen_1.expr)((0, sourcegen_1.ident)('RetryStrategyBuilder'), builder => {
                builder.member((0, sourcegen_1.ident)('noRetries'));
                builder.call(builder => {
                    builder.empty();
                });
            });
        default:
            throw new Error(`Unsupported retry strategy type ${strategy.type}`);
    }
}
exports.valueForRetryStrategy = valueForRetryStrategy;
//# sourceMappingURL=retry-strategy-codegen.js.map