"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserCheck = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const check_1 = require("./check");
const project_1 = require("./project");
const util_1 = require("../services/util");
const construct_1 = require("./construct");
const snapshot_service_1 = require("../services/snapshot-service");
const construct_diagnostics_1 = require("./construct-diagnostics");
const browser_check_bundle_1 = require("./browser-check-bundle");
const check_config_1 = require("./check-config");
/**
 * Creates a Browser Check to monitor web applications using Playwright.
 *
 * Browser checks allow you to monitor complex user interactions, page performance,
 * and visual regressions. They run real browser scripts using Playwright to simulate
 * user behavior and validate web application functionality.
 *
 * @example
 * ```typescript
 * // Basic browser check with script file
 * new BrowserCheck('login-flow', {
 *   name: 'User Login Flow',
 *   frequency: Frequency.EVERY_10M,
 *   locations: ['us-east-1', 'eu-west-1'],
 *   code: {
 *     entrypoint: path.join(__dirname, 'login.spec.js')
 *   }
 * })
 *
 * // Browser check with inline code
 * new BrowserCheck('homepage', {
 *   name: 'Homepage Check',
 *   frequency: Frequency.EVERY_5M,
 *   code: {
 *     content: `
 *       const { test, expect } = require('@playwright/test')
 *
 *       test('homepage loads correctly', async ({ page }) => {
 *         await page.goto('https://example.com')
 *         await expect(page.locator('h1')).toContainText('Welcome')
 *         await expect(page).toHaveTitle(/Example/)
 *       })
 *     `
 *   },
 *   playwrightConfig: {
 *     use: {
 *       viewport: { width: 1280, height: 720 }
 *     }
 *   }
 * })
 * ```
 *
 * @see {@link https://www.checklyhq.com/docs/cli/constructs-reference/#browsercheck | BrowserCheck API Reference}
 * @see {@link https://www.checklyhq.com/docs/monitoring/browser-checks/ | Browser Checks Documentation}
 * @see {@link https://playwright.dev/ | Playwright Documentation}
 */
class BrowserCheck extends check_1.RuntimeCheck {
    code;
    sslCheckDomain;
    playwrightConfig;
    /**
     * Constructs the Browser Check instance
     *
     * @param logicalId unique project-scoped resource name identification
     * @param props check configuration properties
     * {@link https://checklyhq.com/docs/cli/constructs-reference/#browsercheck Read more in the docs}
     */
    constructor(logicalId, props) {
        super(logicalId, props);
        const config = this.applyConfigDefaults(props);
        this.code = config.code;
        this.sslCheckDomain = config.sslCheckDomain;
        this.playwrightConfig = config.playwrightConfig;
        project_1.Session.registerConstruct(this);
        this.addSubscriptions();
        this.addPrivateLocationCheckAssignments();
    }
    describe() {
        return `BrowserCheck:${this.logicalId}`;
    }
    configDefaultsGetter(props) {
        return (0, check_config_1.makeConfigDefaultsGetter)(props.group?.getBrowserCheckDefaults(), project_1.Session.browserCheckDefaults, props.group?.getCheckDefaults(), project_1.Session.checkDefaults);
    }
    applyConfigDefaults(props) {
        const config = super.applyConfigDefaults(props);
        const defaults = this.configDefaultsGetter(props);
        config.playwrightConfig ??= defaults('playwrightConfig');
        return config;
    }
    async validate(diagnostics) {
        await super.validate(diagnostics);
        if (!(0, construct_1.isEntrypoint)(this.code) && !(0, construct_1.isContent)(this.code)) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('code', new Error(`Either "entrypoint" or "content" is required.`)));
        }
        else if ((0, construct_1.isEntrypoint)(this.code) && (0, construct_1.isContent)(this.code)) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('code', new Error(`Provide exactly one of "entrypoint" or "content", but not both.`)));
        }
        else if ((0, construct_1.isEntrypoint)(this.code)) {
            const entrypoint = this.resolveContentFilePath(this.code.entrypoint);
            try {
                const stats = await promises_1.default.stat(entrypoint);
                if (stats.size === 0) {
                    diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('code', new Error(`The entrypoint file "${entrypoint}" must not be empty.`)));
                }
            }
            catch (err) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('code', new Error(`Unable to access entrypoint file "${entrypoint}": ${err.message}`, { cause: err })));
            }
        }
    }
    static async bundle(entry, runtimeId) {
        const runtime = project_1.Session.getRuntime(runtimeId);
        if (!runtime) {
            throw new Error(`${runtimeId} is not supported`);
        }
        const parser = project_1.Session.getParser(runtime);
        const parsed = await parser.parse(entry);
        // Maybe we can get the parsed deps with the content immediately
        const deps = [];
        for (const { filePath, content } of parsed.dependencies) {
            deps.push(project_1.Session.registerSharedFile({
                path: (0, util_1.pathToPosix)(node_path_1.default.relative(project_1.Session.basePath, filePath)),
                content,
            }));
        }
        return {
            script: parsed.entrypoint.content,
            scriptPath: project_1.Session.relativePosixPath(parsed.entrypoint.filePath),
            dependencies: deps,
            snapshots: (0, snapshot_service_1.detectSnapshots)(project_1.Session.basePath, parsed.entrypoint.filePath),
        };
    }
    getSourceFile() {
        return this.__checkFilePath;
    }
    async bundle() {
        return new browser_check_bundle_1.BrowserCheckBundle(this, await (async () => {
            if ((0, construct_1.isEntrypoint)(this.code)) {
                const bundle = await BrowserCheck.bundle(this.resolveContentFilePath(this.code.entrypoint), this.runtimeId);
                if (!bundle.script) {
                    throw new Error(`The "code" property points to an empty file.`);
                }
                return {
                    script: bundle.script,
                    scriptPath: bundle.scriptPath,
                    dependencies: bundle.dependencies,
                    rawSnapshots: bundle.snapshots,
                };
            }
            const script = this.code.content;
            return {
                script,
            };
        })());
    }
    synthesize() {
        return {
            ...super.synthesize(),
            checkType: 'BROWSER',
            sslCheckDomain: this.sslCheckDomain || null, // empty string is converted to null
            playwrightConfig: this.playwrightConfig,
        };
    }
}
exports.BrowserCheck = BrowserCheck;
//# sourceMappingURL=browser-check.js.map