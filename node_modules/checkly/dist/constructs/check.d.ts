import { Ref } from './ref';
import { Frequency } from './frequency';
import { Construct } from './construct';
import { AlertChannel, AlertChannelRef } from './alert-channel';
import { EnvironmentVariable } from './environment-variable';
import type { Region } from '..';
import type { CheckGroupV1, CheckGroupV2, CheckGroupRef } from './check-group';
import { PrivateLocation, PrivateLocationRef } from './private-location';
import { RetryStrategy } from './retry-strategy';
import { AlertEscalation } from './alert-escalation-policy';
import { IncidentTrigger } from './incident';
import { ConfigDefaultsGetter } from './check-config';
import { Diagnostics } from './diagnostics';
/**
 * Base configuration properties for all check types.
 * These properties are inherited by ApiCheck, BrowserCheck, and other check types.
 */
export interface CheckProps {
    /**
     * The display name of the check. This will be shown in the Checkly dashboard.
     *
     * @example "User API Health Check"
     */
    name: string;
    /**
     * Determines whether the check will run periodically after being deployed.
     * Set to `false` to pause a check without deleting it.
     *
     * @defaultValue true
     */
    activated?: boolean;
    /**
     * Determines if any notifications will be sent out when a check fails and/or recovers.
     * Useful for temporarily silencing alerts during maintenance.
     *
     * @defaultValue false
     */
    muted?: boolean;
    /**
     * Setting this to "true" will trigger a retry when a check fails from the failing region and another,
     * randomly selected region before marking the check as failed.
     * @deprecated Use {@link retryStrategy} instead.
     */
    doubleCheck?: boolean;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     * Useful for validating error status codes like 404 or 500.
     * This only applies to API Checks. When set to true, the check passes when
     * it would normally fail, and fails when it would normally pass.
     *
     * @defaultValue false
     * @example
     * ```typescript
     * // Check that expects a 404 status - must set shouldFail: true
     * shouldFail: true,
     * request: {
     *   method: 'GET',
     *   url: 'https://api.example.com/nonexistent',
     *   assertions: [AssertionBuilder.statusCode().equals(404)]
     * }
     * ```
     */
    shouldFail?: boolean;
    /**
     * An array of one or more data center locations where to run this check.
     *
     * @example ['us-east-1', 'eu-west-1', 'ap-southeast-1']
     * @see {@link https://www.checklyhq.com/docs/monitoring/global-locations/ | Global Locations}
     */
    locations?: Array<keyof Region>;
    /**
     * An array of one or more private locations where to run the check.
     * PrivateLocation instances or slug name strings are allowed.
     *
     * `string` slug names are **only** allowed for private locations that **not** belong to the project. Use
     * PrivateLocation instances references for private locations created within the project.
     *
     * @example
     * ```typescript
     * // Using private location instances
     * privateLocations: [myPrivateLocation, anotherPrivateLocation]
     *
     * // Using existing private location slugs
     * privateLocations: ['my-datacenter-1', 'office-location']
     * ```
     */
    privateLocations?: Array<string | PrivateLocation | PrivateLocationRef>;
    /**
     * Tags for organizing and filtering checks in the dashboard.
     *
     * @example ['production', 'api', 'critical']
     */
    tags?: Array<string>;
    /**
     * How often the check should run. Can be specified in minutes or using Frequency constants.
     *
     * @example
     * ```typescript
     * frequency: Frequency.EVERY_5M // Every 5 minutes
     * ```
     */
    frequency?: number | Frequency;
    /**
     * The id of the check group this check is part of. Set this by calling `someGroup.ref()`
     * @deprecated Use {@link group} instead.
     */
    groupId?: Ref;
    /**
     * The CheckGroup that this check is part of.
     * Groups allow you to organize related checks and apply common settings.
     *
     * @example
     * ```typescript
     * // Create a new check group
     * const apiGroup = new CheckGroupV2('api-group', {
     *   name: 'API Checks'
     * })
     *
     * // Reference an existing check group by ID
     * const existingGroup = CheckGroupV2.fromId(123)
     *
     * // Use in check configuration
     * group: apiGroup  // or existingGroup
     * ```
     */
    group?: CheckGroupV1 | CheckGroupV2 | CheckGroupRef;
    /**
     * List of alert channels to notify when the check fails or recovers.
     * If you don't set at least one, we won't be able to alert you in case something goes wrong with your check.
     *
     * @example
     * ```typescript
     * // Create alert channels once at the project level
     * const emailChannel = new EmailAlertChannel('team-email', {
     *   address: 'team@example.com'
     * })
     * const slackChannel = new SlackAlertChannel('team-slack', {
     *   url: 'https://hooks.slack.com/...'
     * })
     *
     * // Reference the channels in your check
     * alertChannels: [emailChannel, slackChannel]
     * ```
     * @see {@link https://www.checklyhq.com/docs/alerting-and-retries/alert-channels/ | Alert Channels}
     */
    alertChannels?: Array<AlertChannel | AlertChannelRef>;
    /**
     * Determines the alert escalation policy for that particular check.
     * Controls when and how alerts are escalated based on failure patterns.
     *
     * @example
     * ```typescript
     * alertEscalationPolicy: AlertEscalationBuilder.runBasedEscalation(3, {
     *   amount: 2,
     *   interval: 10
     * })
     * ```
     */
    alertEscalationPolicy?: AlertEscalation;
    /**
     * Determines if the check is available only when 'test' runs (not included when 'deploy' is executed).
     * Useful for development and testing scenarios.
     *
     * @defaultValue false
     */
    testOnly?: boolean;
    /**
     * Sets a retry policy for the check. Use RetryStrategyBuilder to create a retry policy.
     *
     * @example
     * ```typescript
     * retryStrategy: RetryStrategyBuilder.fixedStrategy({
     *   maxRetries: 3,
     *   baseBackoffSeconds: 30,
     *   sameRegion: false
     * })
     * ```
     */
    retryStrategy?: RetryStrategy;
    /**
     * Determines whether the check should run on all selected locations in parallel or round-robin.
     *
     * @defaultValue false (round-robin)
     * @see {@link https://www.checklyhq.com/docs/monitoring/global-locations/ | Scheduling Strategies}
     */
    runParallel?: boolean;
    /**
     * Determines whether the check should create and resolve an incident based on its alert configuration.
     * Useful for status page automation.
     *
     * @see {@link https://www.checklyhq.com/docs/status-pages/incidents/#incident-automation | Incident Automation}
     */
    triggerIncident?: IncidentTrigger;
}
export declare abstract class Check extends Construct {
    name: string;
    activated?: boolean;
    muted?: boolean;
    doubleCheck?: boolean;
    shouldFail?: boolean;
    locations?: Array<keyof Region>;
    privateLocations?: Array<string | PrivateLocation | PrivateLocationRef>;
    tags?: Array<string>;
    frequency?: number;
    frequencyOffset?: number;
    groupId?: Ref;
    alertChannels?: Array<AlertChannel | AlertChannelRef>;
    testOnly?: boolean;
    retryStrategy?: RetryStrategy;
    alertSettings?: AlertEscalation;
    useGlobalAlertSettings?: boolean;
    runParallel?: boolean;
    triggerIncident?: IncidentTrigger;
    __checkFilePath?: string;
    static readonly __checklyType = "check";
    protected constructor(logicalId: string, props: CheckProps);
    protected validateDoubleCheck(diagnostics: Diagnostics): Promise<void>;
    protected validateRetryStrategyOnlyOn(diagnostics: Diagnostics): Promise<void>;
    protected supportsOnlyOnNetworkErrorRetryStrategy(): boolean;
    validate(diagnostics: Diagnostics): Promise<void>;
    protected configDefaultsGetter(props: CheckProps): ConfigDefaultsGetter;
    protected applyConfigDefaults<T extends CheckProps>(props: T): T;
    /**
     * Creates alert channel subscriptions for this check.
     * Links the check to its configured alert channels to send notifications.
     * Only creates subscriptions if alert channels are configured and check is not test-only.
     */
    addSubscriptions(): void;
    /**
     * Creates private location assignments for this check.
     * Links the check to its configured private locations so it can run on them.
     * Only processes PrivateLocation instances, not string slugs.
     */
    addPrivateLocationCheckAssignments(): void;
    /**
     * Gets the source file path where this check was defined.
     * Used for filtering and debugging purposes.
     *
     * @returns The absolute path to the check file, or undefined if not set
     */
    getSourceFile(): string | undefined;
    synthesize(): {
        name: string;
        activated: boolean | undefined;
        muted: boolean | undefined;
        shouldFail: boolean | undefined;
        locations: (keyof Region)[] | undefined;
        privateLocations: undefined;
        tags: string[] | undefined;
        frequency: number | undefined;
        frequencyOffset: number | undefined;
        groupId: Ref | null;
        retryStrategy: RetryStrategy | null | undefined;
        doubleCheck: boolean | undefined;
        alertSettings: AlertEscalation | undefined;
        useGlobalAlertSettings: boolean | undefined;
        runParallel: boolean | undefined;
        triggerIncident: {
            serviceId: Ref;
            severity: "MINOR" | "MEDIUM" | "MAJOR" | "CRITICAL";
            name: string;
            description: string;
            notifySubscribers: boolean;
        } | undefined;
    };
}
export interface RuntimeCheckProps extends CheckProps {
    /**
     * The runtime version, i.e. fixed set of runtime dependencies, used to execute this check.
     *
     * @example "2024.09"
     * @see {@link https://www.checklyhq.com/docs/runtimes/ | Runtime Documentation}
     */
    runtimeId?: string;
    /**
     * Environment variables available to the check script.
     * Maximum of 50 environment variables per check.
     *
     * @maxItems 50
     * @example
     * ```typescript
     * environmentVariables: [
     *   { key: 'API_TOKEN', value: '{{API_TOKEN}}', secret: true },
     *   { key: 'BASE_URL', value: 'https://api.example.com' }
     * ]
     * ```
     */
    environmentVariables?: EnvironmentVariable[];
}
export declare abstract class RuntimeCheck extends Check {
    runtimeId?: string;
    environmentVariables?: EnvironmentVariable[];
    protected constructor(logicalId: string, props: RuntimeCheckProps);
    protected applyConfigDefaults<T extends RuntimeCheckProps>(props: T): T;
    synthesize(): {
        runtimeId: string | undefined;
        environmentVariables: import("./key-value-pair").default[] | undefined;
        name: string;
        activated: boolean | undefined;
        muted: boolean | undefined;
        shouldFail: boolean | undefined;
        locations: (keyof Region)[] | undefined;
        privateLocations: undefined;
        tags: string[] | undefined;
        frequency: number | undefined;
        frequencyOffset: number | undefined;
        groupId: Ref | null;
        retryStrategy: RetryStrategy | null | undefined;
        doubleCheck: boolean | undefined;
        alertSettings: AlertEscalation | undefined;
        useGlobalAlertSettings: boolean | undefined;
        runParallel: boolean | undefined;
        triggerIncident: {
            serviceId: Ref;
            severity: "MINOR" | "MEDIUM" | "MAJOR" | "CRITICAL";
            name: string;
            description: string;
            notifySubscribers: boolean;
        } | undefined;
    };
}
