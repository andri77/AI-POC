"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckCodegen = exports.buildRuntimeCheckProps = exports.buildCheckProps = void 0;
const codegen_1 = require("./internal/codegen");
const alert_escalation_policy_codegen_1 = require("./alert-escalation-policy-codegen");
const api_check_codegen_1 = require("./api-check-codegen");
const browser_check_codegen_1 = require("./browser-check-codegen");
const check_group_codegen_1 = require("./check-group-codegen");
const frequency_codegen_1 = require("./frequency-codegen");
const heartbeat_monitor_codegen_1 = require("./heartbeat-monitor-codegen");
const key_value_pair_codegen_1 = require("./key-value-pair-codegen");
const multi_step_check_codegen_1 = require("./multi-step-check-codegen");
const retry_strategy_codegen_1 = require("./retry-strategy-codegen");
const tcp_monitor_codegen_1 = require("./tcp-monitor-codegen");
const url_monitor_codegen_1 = require("./url-monitor-codegen");
const private_location_codegen_1 = require("./private-location-codegen");
const alert_channel_codegen_1 = require("./alert-channel-codegen");
function buildCheckProps(program, genfile, builder, resource, context) {
    builder.string('name', resource.name, { order: -1000 });
    if (resource.activated !== undefined) {
        builder.boolean('activated', resource.activated);
    }
    if (resource.muted !== undefined) {
        builder.boolean('muted', resource.muted);
    }
    if (resource.shouldFail !== undefined) {
        builder.boolean('shouldFail', resource.shouldFail);
    }
    if (resource.locations) {
        const locations = resource.locations;
        if (locations.length > 0) {
            builder.array('locations', builder => {
                for (const location of locations) {
                    builder.string(location);
                }
            });
        }
    }
    const privateLocationIds = (() => {
        try {
            return context.lookupCheckPrivateLocations(resource.id);
        }
        catch {
            return;
        }
    })();
    if (privateLocationIds !== undefined) {
        builder.array('privateLocations', builder => {
            for (const privateLocationId of privateLocationIds) {
                try {
                    const privateLocationVariable = context.lookupPrivateLocation(privateLocationId);
                    const id = context.importVariable(privateLocationVariable, genfile);
                    builder.value(id);
                }
                catch {
                    try {
                        const privateLocationVariable = context.lookupFriendPrivateLocation(privateLocationId);
                        const id = context.importFriendVariable(privateLocationVariable, genfile);
                        builder.value(id);
                    }
                    catch {
                        builder.value((0, private_location_codegen_1.valueForPrivateLocationFromId)(genfile, privateLocationId));
                    }
                }
            }
        });
    }
    if (resource.tags) {
        const tags = resource.tags;
        if (tags.length > 0) {
            builder.array('tags', builder => {
                for (const tag of tags) {
                    builder.string(tag);
                }
            });
        }
    }
    if (resource.frequency !== undefined) {
        if (typeof resource.frequency === 'number') {
            builder.value('frequency', (0, frequency_codegen_1.valueForFrequency)(genfile, {
                frequency: resource.frequency,
                frequencyOffset: resource.frequencyOffset,
            }));
        }
        else {
            builder.value('frequency', (0, frequency_codegen_1.valueForFrequency)(genfile, resource.frequency));
        }
    }
    if (resource.groupId) {
        try {
            const groupVariable = context.lookupCheckGroup(resource.groupId);
            const id = context.importVariable(groupVariable, genfile);
            builder.value('group', id);
        }
        catch {
            try {
                const groupVariable = context.lookupFriendCheckGroup(resource.groupId);
                const id = context.importFriendVariable(groupVariable, genfile);
                builder.value('group', id);
            }
            catch {
                builder.value('group', (0, check_group_codegen_1.valueForCheckGroupFromId)(genfile, resource.groupId));
            }
        }
    }
    const alertChannelIds = (() => {
        try {
            return context.lookupCheckAlertChannels(resource.id);
        }
        catch {
            return;
        }
    })();
    if (alertChannelIds !== undefined) {
        builder.array('alertChannels', builder => {
            for (const alertChannelId of alertChannelIds) {
                try {
                    const alertChannelVariable = context.lookupAlertChannel(alertChannelId);
                    const id = context.importVariable(alertChannelVariable, genfile);
                    builder.value(id);
                }
                catch {
                    try {
                        const alertChannelVariable = context.lookupFriendAlertChannel(alertChannelId);
                        const id = context.importFriendVariable(alertChannelVariable, genfile);
                        builder.value(id);
                    }
                    catch {
                        builder.value((0, alert_channel_codegen_1.valueForAlertChannelFromId)(genfile, alertChannelId));
                    }
                }
            }
        });
    }
    if (resource.alertSettings) {
        builder.value('alertEscalationPolicy', (0, alert_escalation_policy_codegen_1.valueForAlertEscalation)(genfile, resource.alertSettings));
    }
    if (resource.testOnly !== undefined) {
        builder.boolean('testOnly', resource.testOnly);
    }
    builder.value('retryStrategy', (0, retry_strategy_codegen_1.valueForRetryStrategy)(genfile, resource.retryStrategy));
    if (resource.runParallel !== undefined) {
        builder.boolean('runParallel', resource.runParallel);
    }
}
exports.buildCheckProps = buildCheckProps;
function buildRuntimeCheckProps(program, genfile, builder, resource, context) {
    buildCheckProps(program, genfile, builder, resource, context);
    if (resource.runtimeId) {
        builder.string('runtimeId', resource.runtimeId);
    }
    if (resource.environmentVariables) {
        const variables = resource.environmentVariables;
        if (variables.length > 0) {
            builder.array('environmentVariables', builder => {
                for (const variable of variables) {
                    builder.value((0, key_value_pair_codegen_1.valueForKeyValuePair)(program, genfile, context, variable));
                }
            });
        }
    }
}
exports.buildRuntimeCheckProps = buildRuntimeCheckProps;
class CheckCodegen extends codegen_1.Codegen {
    apiCheckCodegen;
    browserCheckCodegen;
    checkGroupCodegen;
    heartbeatMonitorCodegen;
    multiStepCheckCodegen;
    tcpMonitorCodegen;
    urlMonitorCodegen;
    constructor(program) {
        super(program);
        this.apiCheckCodegen = new api_check_codegen_1.ApiCheckCodegen(program);
        this.browserCheckCodegen = new browser_check_codegen_1.BrowserCheckCodegen(program);
        this.checkGroupCodegen = new check_group_codegen_1.CheckGroupCodegen(program);
        this.heartbeatMonitorCodegen = new heartbeat_monitor_codegen_1.HeartbeatMonitorCodegen(program);
        this.multiStepCheckCodegen = new multi_step_check_codegen_1.MultiStepCheckCodegen(program);
        this.tcpMonitorCodegen = new tcp_monitor_codegen_1.TcpMonitorCodegen(program);
        this.urlMonitorCodegen = new url_monitor_codegen_1.UrlMonitorCodegen(program);
    }
    describe(resource) {
        const { checkType } = resource;
        switch (checkType) {
            case 'BROWSER':
                return this.browserCheckCodegen.describe(resource);
            case 'API':
                return this.apiCheckCodegen.describe(resource);
            case 'TCP':
                return this.tcpMonitorCodegen.describe(resource);
            case 'MULTI_STEP':
                return this.multiStepCheckCodegen.describe(resource);
            case 'HEARTBEAT':
                return this.heartbeatMonitorCodegen.describe(resource);
            case 'URL':
                return this.urlMonitorCodegen.describe(resource);
            default:
                throw new Error(`Unable to describe unsupported check type '${checkType}'.`);
        }
    }
    gencode(logicalId, resource, context) {
        const { checkType } = resource;
        switch (checkType) {
            case 'BROWSER':
                this.browserCheckCodegen.gencode(logicalId, resource, context);
                return;
            case 'API':
                this.apiCheckCodegen.gencode(logicalId, resource, context);
                return;
            case 'TCP':
                this.tcpMonitorCodegen.gencode(logicalId, resource, context);
                return;
            case 'MULTI_STEP':
                this.multiStepCheckCodegen.gencode(logicalId, resource, context);
                return;
            case 'HEARTBEAT':
                this.heartbeatMonitorCodegen.gencode(logicalId, resource, context);
                return;
            case 'URL':
                this.urlMonitorCodegen.gencode(logicalId, resource, context);
                return;
            default:
                throw new Error(`Unable to generate code for unsupported check type '${checkType}'.`);
        }
    }
}
exports.CheckCodegen = CheckCodegen;
//# sourceMappingURL=check-codegen.js.map