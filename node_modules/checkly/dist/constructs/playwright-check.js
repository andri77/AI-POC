"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaywrightCheck = void 0;
const node_fs_1 = require("node:fs");
const promises_1 = __importDefault(require("node:fs/promises"));
const api_1 = require("../rest/api");
const util_1 = require("../services/util");
const check_1 = require("./check");
const construct_diagnostics_1 = require("./construct-diagnostics");
const playwright_check_bundle_1 = require("./playwright-check-bundle");
const project_1 = require("./project");
/**
 * Creates a Playwright Check to run end-to-end tests using Playwright Test.
 *
 * Playwright check suites allow you to monitor complex user interactions and workflows
 * by running your existing Playwright test suites as monitoring checks. They support
 * multiple browsers, test filtering, and custom test commands.
 *
 * @example
 * ```typescript
 * // Basic Playwright check
 * new PlaywrightCheck('e2e-login', {
 *   name: 'Login Flow E2E Test',
 *   playwrightConfigPath: '../playwright.config.js',
 *   frequency: Frequency.EVERY_10M,
 *   locations: ['us-east-1', 'eu-west-1']
 * })
 *
 * // Advanced check with projects and tags
 * new PlaywrightCheck('critical-flows', {
 *   name: 'Critical User Flows',
 *   playwrightConfigPath: '../playwright.config.js',
 *   installCommand: 'npm ci',
 *   pwProjects: ['chromium', 'firefox'],
 *   pwTags: ['@smoke', '@critical'],
 *   include: ['tests/**\/*', 'utils/**\/*'],
 *   groupName: 'E2E Tests',
 *   frequency: Frequency.EVERY_5M
 * })
 * ```
 *
 * @see {@link https://www.checklyhq.com/docs/cli/constructs-reference/#playwrightcheck | PlaywrightCheck API Reference}
 * @see {@link https://www.checklyhq.com/docs/playwright-checks/ | Playwright Checks Documentation}
 * @see {@link https://playwright.dev/ | Playwright Documentation}
 */
class PlaywrightCheck extends check_1.RuntimeCheck {
    installCommand;
    testCommand;
    playwrightConfigPath;
    pwProjects;
    pwTags;
    include;
    groupName;
    constructor(logicalId, props) {
        super(logicalId, props);
        this.installCommand = props.installCommand;
        this.pwProjects = props.pwProjects
            ? (Array.isArray(props.pwProjects) ? props.pwProjects : [props.pwProjects])
            : [];
        this.pwTags = props.pwTags
            ? (Array.isArray(props.pwTags) ? props.pwTags : [props.pwTags])
            : [];
        this.include = props.include
            ? (Array.isArray(props.include) ? props.include : [props.include])
            : [];
        this.testCommand = props.testCommand ?? 'npx playwright test';
        this.groupName = props.groupName;
        this.playwrightConfigPath = this.resolveContentFilePath(props.playwrightConfigPath);
        project_1.Session.registerConstruct(this);
        this.addSubscriptions();
        this.addPrivateLocationCheckAssignments();
    }
    describe() {
        return `PlaywrightCheck:${this.logicalId}`;
    }
    async validate(diagnostics) {
        await super.validate(diagnostics);
        try {
            await promises_1.default.access(this.playwrightConfigPath, promises_1.default.constants.R_OK);
        }
        catch (err) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('playwrightConfigPath', new Error(`Playwright config "${this.playwrightConfigPath}" does not exist: ${err.message}`, { cause: err })));
        }
        if (this.groupName) {
            const checkGroup = this.#findGroupByName(this.groupName);
            if (!checkGroup) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('groupName', new Error(`No such group "${this.groupName}".`)));
            }
        }
    }
    #findGroupByName(groupName) {
        return Object.values(project_1.Session.project?.data?.['check-group'] ?? {})
            .find(group => group.name === groupName);
    }
    getSourceFile() {
        return this.__checkFilePath;
    }
    static buildTestCommand(testCommand, playwrightConfigPath, playwrightProject, playwrightTag) {
        const quotedPath = `"${playwrightConfigPath}"`;
        const projectArg = playwrightProject?.length ? ' --project ' + playwrightProject.map(p => `"${p}"`).join(' ') : '';
        const tagArg = playwrightTag?.length ? ' --grep "' + playwrightTag.join('|').replace(/"/g, '\\"') + '"' : '';
        return `${testCommand} --config ${quotedPath}${projectArg}${tagArg}`;
    }
    static async bundleProject(playwrightConfigPath, include) {
        let dir = '';
        try {
            const { outputFile, browsers, relativePlaywrightConfigPath, cacheHash, playwrightVersion, } = await (0, util_1.bundlePlayWrightProject)(playwrightConfigPath, include);
            dir = outputFile;
            const { data: { key } } = await PlaywrightCheck.uploadPlaywrightProject(dir);
            return { key, browsers, relativePlaywrightConfigPath, cacheHash, playwrightVersion };
        }
        finally {
            await (0, util_1.cleanup)(dir);
        }
    }
    static async uploadPlaywrightProject(dir) {
        const { size } = await promises_1.default.stat(dir);
        const stream = (0, node_fs_1.createReadStream)(dir);
        stream.on('error', err => {
            throw new Error(`Failed to read Playwright project file: ${err.message}`);
        });
        return api_1.checklyStorage.uploadCodeBundle(stream, size);
    }
    async bundle() {
        let groupId;
        if (this.groupName) {
            const checkGroup = this.#findGroupByName(this.groupName);
            if (checkGroup) {
                groupId = checkGroup.ref();
            }
        }
        const { key: codeBundlePath, browsers, cacheHash, playwrightVersion, relativePlaywrightConfigPath, } = await PlaywrightCheck.bundleProject(this.playwrightConfigPath, this.include ?? []);
        const testCommand = PlaywrightCheck.buildTestCommand(this.testCommand, relativePlaywrightConfigPath, this.pwProjects, this.pwTags);
        return new playwright_check_bundle_1.PlaywrightCheckBundle(this, {
            groupId,
            codeBundlePath,
            browsers,
            cacheHash,
            playwrightVersion,
            testCommand,
            installCommand: this.installCommand,
        });
    }
    synthesize() {
        return {
            ...super.synthesize(),
            checkType: 'PLAYWRIGHT',
        };
    }
}
exports.PlaywrightCheck = PlaywrightCheck;
//# sourceMappingURL=playwright-check.js.map