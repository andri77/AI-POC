"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateResponseTimes = exports.validateRemovedDoubleCheck = exports.validateDeprecatedDoubleCheck = void 0;
const construct_diagnostics_1 = require("../construct-diagnostics");
// eslint-disable-next-line require-await
async function validateDoubleCheck(diagnostics, kind, props) {
    if (props.doubleCheck !== undefined) {
        if (props.doubleCheck) {
            diagnostics.add(new kind('doubleCheck', new Error(`To match the behavior of doubleCheck: true, please use the `
                + `following retryStrategy instead:`
                + `\n\n`
                + `  RetryStrategyBuilder.fixedStrategy({\n`
                + `    maxRetries: 1,\n`
                + `    baseBackoffSeconds: 0,\n`
                + `    maxDurationSeconds: 600,\n`
                + `    sameRegion: false,\n`
                + `  })`)));
        }
        else {
            diagnostics.add(new kind('doubleCheck', new Error(`To match the behavior of doubleCheck: false, please use the `
                + `following retryStrategy instead:`
                + `\n\n`
                + `  RetryStrategyBuilder.noRetries()`)));
        }
    }
}
async function validateDeprecatedDoubleCheck(diagnostics, props) {
    if (props.doubleCheck !== undefined) {
        if (props.retryStrategy) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('doubleCheck', new Error('Cannot specify both "doubleCheck" and "retryStrategy".')));
        }
        await validateDoubleCheck(diagnostics, construct_diagnostics_1.DeprecatedPropertyDiagnostic, props);
    }
}
exports.validateDeprecatedDoubleCheck = validateDeprecatedDoubleCheck;
async function validateRemovedDoubleCheck(diagnostics, props) {
    await validateDoubleCheck(diagnostics, construct_diagnostics_1.RemovedPropertyDiagnostic, props);
}
exports.validateRemovedDoubleCheck = validateRemovedDoubleCheck;
// eslint-disable-next-line require-await
async function validateResponseTimes(diagnostics, props, limits) {
    if (props.degradedResponseTime !== undefined) {
        const value = props.degradedResponseTime;
        const limit = limits.degradedResponseTime;
        if (value > limit) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('degradedResponseTime', new Error(`The value of "degradedResponseTime" must be ${limit} or lower.`
                + `\n\n`
                + `The current value is ${value}.`)));
        }
    }
    if (props.maxResponseTime !== undefined) {
        const value = props.maxResponseTime;
        const limit = limits.maxResponseTime;
        if (value > limit) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('maxResponseTime', new Error(`The value of "maxResponseTime" must be ${limit} or lower.`
                + `\n\n`
                + `The current value is ${value}.`)));
        }
    }
}
exports.validateResponseTimes = validateResponseTimes;
//# sourceMappingURL=common-diagnostics.js.map